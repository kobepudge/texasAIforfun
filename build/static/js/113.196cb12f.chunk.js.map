{"version":3,"file":"static/js/113.196cb12f.chunk.js","mappings":"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","sources":["ai/adaptive-prompt-manager.ts","ai/ai-api-pool.ts","ai/situation-complexity-analyzer.ts","ai/fast-decision-engine.ts"],"sourcesContent":["import { NewGameState } from '../core/game-engine';\nimport { Card } from '../types/poker';\n\n// 🎯 自适应Prompt管理器\nexport class AdaptivePromptManager {\n  \n  // 📝 根据复杂度生成对应的Prompt\n  generatePrompt(\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[],\n    complexityLevel: 'minimal' | 'standard' | 'detailed' | 'comprehensive',\n    timeLimit: number,\n    temperature: number\n  ): string {\n    \n    switch (complexityLevel) {\n      case 'minimal':\n        return this.generateMinimalPrompt(gameState, playerId, holeCards, timeLimit);\n      case 'standard':\n        return this.generateStandardPrompt(gameState, playerId, holeCards, timeLimit);\n      case 'detailed':\n        return this.generateDetailedPrompt(gameState, playerId, holeCards, timeLimit, temperature);\n      case 'comprehensive':\n        return this.generateComprehensivePrompt(gameState, playerId, holeCards, timeLimit, temperature);\n      default:\n        return this.generateStandardPrompt(gameState, playerId, holeCards, timeLimit);\n    }\n  }\n\n  // ⚡ 极简Prompt - 用于明显决策\n  private generateMinimalPrompt(\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[],\n    timeLimit: number\n  ): string {\n    const player = gameState.players.find(p => p.id === playerId);\n    const handStr = `${holeCards[0].rank}${holeCards[0].suit}${holeCards[1].rank}${holeCards[1].suit}`;\n    const pot = gameState.pot;\n    const toCall = this.getAmountToCall(gameState, playerId);\n    const stack = player?.chips || 0;\n    \n    return `FAST_POKER_DECISION\nHand: ${handStr}\nPot: ${pot}\nToCall: ${toCall}\nStack: ${stack}\nPhase: ${gameState.phase}\nBoard: ${this.getBoardString(gameState.communityCards)}\n\nRESPOND_JSON_ONLY:\n{\"action\": \"fold/call/raise\", \"amount\": number, \"confidence\": 0.8}`;\n  }\n\n  // 📊 标准Prompt - 用于常规决策\n  private generateStandardPrompt(\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[],\n    timeLimit: number\n  ): string {\n    const player = gameState.players.find(p => p.id === playerId);\n    const handStr = `${holeCards[0].rank}${holeCards[0].suit}${holeCards[1].rank}${holeCards[1].suit}`;\n    const position = this.getPlayerPosition(gameState, playerId);\n    const opponents = this.getActiveOpponents(gameState, playerId);\n    \n    return `PokerGPT-Pro标准分析 | 时限: ${timeLimit}ms\n\n🃏 手牌: ${handStr}\n📍 位置: ${position}\n💰 筹码: ${player?.chips || 0}\n🎯 底池: ${gameState.pot}\n📋 阶段: ${gameState.phase}\n🎲 牌面: ${this.getBoardString(gameState.communityCards)}\n👥 对手: ${opponents.length}人\n\n快速分析要求:\n1. 手牌强度 (1-10)\n2. 位置优势评估\n3. 底池赔率计算\n4. 基础GTO策略\n\nJSON格式回复:\n{\n  \"action\": \"fold/call/raise\",\n  \"amount\": number,\n  \"confidence\": 0.8,\n  \"reasoning\": \"简洁理由(15字内)\",\n  \"hand_strength\": 7,\n  \"position_factor\": \"early/middle/late\"\n}`;\n  }\n\n  // 🔍 详细Prompt - 用于复杂决策\n  private generateDetailedPrompt(\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[],\n    timeLimit: number,\n    temperature: number\n  ): string {\n    const player = gameState.players.find(p => p.id === playerId);\n    const handStr = `${holeCards[0].rank}${holeCards[0].suit}${holeCards[1].rank}${holeCards[1].suit}`;\n    const actionHistory = this.getActionHistory(gameState);\n    const potOdds = this.calculatePotOdds(gameState, playerId);\n    const stackSizes = this.getStackSizes(gameState);\n    \n    return `PokerGPT-Pro深度分析 | 时限: ${timeLimit}ms | 温度: ${temperature}\n\n🎮 游戏状态:\n- 手牌: ${handStr}\n- 位置: ${this.getPlayerPosition(gameState, playerId)}\n- 筹码: ${player?.chips || 0} (${Math.round((player?.chips || 0) / gameState.bigBlind)}BB)\n- 底池: ${gameState.pot} (${Math.round(gameState.pot / gameState.bigBlind)}BB)\n- 阶段: ${gameState.phase}\n- 牌面: ${this.getBoardString(gameState.communityCards)}\n\n📊 关键数据:\n- 底池赔率: ${potOdds}\n- 跟注金额: ${this.getAmountToCall(gameState, playerId)}\n- SPR: ${this.calculateSPR(gameState, playerId)}\n- 对手数量: ${this.getActiveOpponents(gameState, playerId).length}\n\n📈 行动历史:\n${actionHistory.slice(-5).map(a => `${a.player}: ${a.action} ${a.amount || ''}`).join('\\n')}\n\n🎯 分析要求:\n1. 手牌强度评估 (考虑牌面结构)\n2. 位置优势分析\n3. 对手范围估计\n4. 底池赔率 vs 胜率计算\n5. 隐含赔率考虑\n6. GTO基础 + 对手调整\n\nJSON格式回复:\n{\n  \"action\": \"fold/call/raise\",\n  \"amount\": number,\n  \"confidence\": 0.8,\n  \"reasoning\": \"详细推理(30字内)\",\n  \"hand_strength\": 7,\n  \"position_factor\": \"early/middle/late\",\n  \"opponent_adjustment\": \"tighter/standard/looser\",\n  \"pot_odds_analysis\": \"favorable/marginal/unfavorable\"\n}`;\n  }\n\n  // 🧠 综合Prompt - 用于极复杂决策\n  private generateComprehensivePrompt(\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[],\n    timeLimit: number,\n    temperature: number\n  ): string {\n    const player = gameState.players.find(p => p.id === playerId);\n    const handStr = `${holeCards[0].rank}${holeCards[0].suit}${holeCards[1].rank}${holeCards[1].suit}`;\n    const boardTexture = this.analyzeBoardTexture(gameState.communityCards);\n    const opponentProfiles = this.getOpponentProfiles(gameState, playerId);\n    const gameFlow = this.analyzeGameFlow(gameState);\n    \n    return `PokerGPT-Pro专家级分析 | 时限: ${timeLimit}ms | 温度: ${temperature}\n\n🎮 完整游戏状态:\n- 手牌: ${handStr}\n- 位置: ${this.getPlayerPosition(gameState, playerId)} (${this.getPositionDetails(gameState, playerId)})\n- 筹码: ${player?.chips || 0} (${Math.round((player?.chips || 0) / gameState.bigBlind)}BB)\n- 底池: ${gameState.pot} (${Math.round(gameState.pot / gameState.bigBlind)}BB)\n- 阶段: ${gameState.phase}\n- 牌面: ${this.getBoardString(gameState.communityCards)}\n\n🎲 牌面分析:\n- 结构: ${boardTexture.texture}\n- 听牌: ${boardTexture.draws}\n- 危险度: ${boardTexture.danger}\n\n👥 对手档案:\n${opponentProfiles.map(p => `${p.name}: ${p.style} (VPIP: ${p.vpip}%, PFR: ${p.pfr}%)`).join('\\n')}\n\n📊 高级数据:\n- 底池赔率: ${this.calculatePotOdds(gameState, playerId)}\n- SPR: ${this.calculateSPR(gameState, playerId)}\n- 隐含赔率: ${this.calculateImpliedOdds(gameState, playerId)}\n- 反向隐含赔率: ${this.calculateReverseImpliedOdds(gameState, playerId)}\n\n📈 游戏流程:\n- 翻前行动: ${gameFlow.preflop}\n- 翻后趋势: ${gameFlow.postflop}\n- 激进度: ${gameFlow.aggression}\n\n🎯 专家级分析要求:\n1. 精确手牌强度评估 (考虑所有因素)\n2. 对手范围构建与更新\n3. 多层次EV计算 (直接+隐含+反向隐含)\n4. 心理博弈层次分析\n5. 平衡策略考虑\n6. Meta-game调整\n7. 风险管理评估\n\nJSON格式回复:\n{\n  \"action\": \"fold/call/raise\",\n  \"amount\": number,\n  \"confidence\": 0.8,\n  \"reasoning\": \"深度推理(50字内)\",\n  \"hand_strength\": 7,\n  \"position_factor\": \"early/middle/late\",\n  \"opponent_adjustment\": \"tighter/standard/looser\",\n  \"play_type\": \"value/bluff/protection/pot_control\",\n  \"ev_analysis\": {\n    \"fold_ev\": number,\n    \"call_ev\": number,\n    \"raise_ev\": number\n  },\n  \"risk_assessment\": \"low/medium/high\",\n  \"meta_considerations\": \"string\"\n}`;\n  }\n\n  // 辅助方法 (简化实现)\n  private getBoardString(communityCards: Card[]): string {\n    if (!communityCards || !communityCards.length) return \"无\";\n    return communityCards.map(c => `${c.rank}${c.suit}`).join(' ');\n  }\n\n  private getPlayerPosition(gameState: NewGameState, playerId: string): string {\n    return \"middle\"; // 简化实现\n  }\n\n  private getActiveOpponents(gameState: NewGameState, playerId: string): any[] {\n    return gameState.players.filter(p => p.isActive && p.id !== playerId);\n  }\n\n  private getAmountToCall(gameState: NewGameState, playerId: string): number {\n    return 0; // 简化实现\n  }\n\n  private calculatePotOdds(gameState: NewGameState, playerId: string): string {\n    return \"2:1\"; // 简化实现\n  }\n\n  private calculateSPR(gameState: NewGameState, playerId: string): number {\n    return 5.0; // 简化实现\n  }\n\n  private getActionHistory(gameState: NewGameState): Array<{player: string; action: string; amount?: number}> {\n    return []; // 简化实现\n  }\n\n  private getStackSizes(gameState: NewGameState): string {\n    return \"深筹码\"; // 简化实现\n  }\n\n  private analyzeBoardTexture(communityCards: Card[]): {texture: string; draws: string; danger: string} {\n    return {texture: \"干燥\", draws: \"无\", danger: \"低\"}; // 简化实现\n  }\n\n  private getOpponentProfiles(gameState: NewGameState, playerId: string): Array<{name: string; style: string; vpip: number; pfr: number}> {\n    return []; // 简化实现\n  }\n\n  private analyzeGameFlow(gameState: NewGameState): {preflop: string; postflop: string; aggression: string} {\n    return {preflop: \"标准\", postflop: \"被动\", aggression: \"中等\"}; // 简化实现\n  }\n\n  private getPositionDetails(gameState: NewGameState, playerId: string): string {\n    return \"CO位\"; // 简化实现\n  }\n\n  private calculateImpliedOdds(gameState: NewGameState, playerId: string): string {\n    return \"良好\"; // 简化实现\n  }\n\n  private calculateReverseImpliedOdds(gameState: NewGameState, playerId: string): string {\n    return \"中等\"; // 简化实现\n  }\n}\n","import { AIDecision } from './ai-player';\n\n// 🔧 API配置\nexport interface APIConfig {\n  apiKey: string;\n  baseUrl: string;\n  model: string;\n  temperature: number;\n  maxTokens: number;\n  timeout: number;\n}\n\n// 📊 API连接状态\nexport interface APIConnection {\n  id: string;\n  config: APIConfig;\n  isActive: boolean;\n  requestCount: number;\n  errorCount: number;\n  averageResponseTime: number;\n  lastUsed: number;\n}\n\n// 🚀 AI API连接池\nexport class AIAPIPool {\n  private connections: APIConnection[] = [];\n  private currentConnectionIndex: number = 0;\n  private requestQueue: PendingRequest[] = [];\n  private isProcessingQueue: boolean = false;\n\n  constructor(apiConfig: APIConfig, poolSize: number = 3) {\n    this.initializeConnections(apiConfig, poolSize);\n    this.startQueueProcessor();\n    \n    console.log(`🚀 AI API连接池初始化完成 (${poolSize}个连接)`);\n  }\n\n  // 🏗️ 初始化连接池\n  private initializeConnections(baseConfig: APIConfig, poolSize: number): void {\n    for (let i = 0; i < poolSize; i++) {\n      const connection: APIConnection = {\n        id: `conn_${i}`,\n        config: { ...baseConfig },\n        isActive: true,\n        requestCount: 0,\n        errorCount: 0,\n        averageResponseTime: 0,\n        lastUsed: 0\n      };\n      \n      this.connections.push(connection);\n    }\n  }\n\n  // 🎯 发起决策请求\n  async makeDecisionRequest(prompt: string, timeLimit: number): Promise<AIDecision> {\n    return this.makeDecisionRequestWithConfig(prompt, timeLimit, this.connections[0]?.config.temperature || 0.1);\n  }\n\n  // 🎯 发起带配置的决策请求\n  async makeDecisionRequestWithConfig(prompt: string, timeLimit: number, temperature: number): Promise<AIDecision> {\n    const startTime = Date.now();\n\n    try {\n      // 选择最佳连接\n      const connection = this.selectBestConnection();\n\n      // 发起请求（使用动态温度）\n      const response = await this.makeAPIRequestWithConfig(connection, prompt, timeLimit, temperature);\n\n      // 解析响应\n      const decision = this.parseAIResponse(response);\n\n      // 更新连接统计\n      this.updateConnectionStats(connection, Date.now() - startTime, true);\n\n      return decision;\n\n    } catch (error) {\n      console.error('❌ AI API请求失败:', error);\n\n      // 尝试备用连接\n      return await this.tryBackupRequestWithConfig(prompt, timeLimit, temperature, startTime);\n    }\n  }\n\n  // 🔄 并行请求（修复版本 - 等待第一个成功的请求）\n  async makeParallelRequest(prompt: string, timeLimit: number): Promise<AIDecision> {\n    const activeConnections = this.connections.filter(c => c.isActive);\n\n    if (activeConnections.length === 0) {\n      throw new Error('没有可用的API连接');\n    }\n\n    // 🚀 优化：对于德州扑克，直接使用单一请求更高效\n    console.log('🎯 使用单一请求替代并行请求（更稳定）');\n    return this.makeDecisionRequest(prompt, timeLimit);\n\n    // 注释掉原来的并行逻辑，保留以备将来需要\n    /*\n    // 同时发起多个请求\n    const promises = activeConnections.slice(0, 2).map(async (connection) => {\n      try {\n        const response = await this.makeAPIRequest(connection, prompt, timeLimit);\n        return this.parseAIResponse(response);\n      } catch (error) {\n        throw error;\n      }\n    });\n\n    // 使用Promise.allSettled等待所有请求完成，返回第一个成功的\n    const results = await Promise.allSettled(promises);\n    const successfulResult = results.find(result => result.status === 'fulfilled');\n\n    if (successfulResult && successfulResult.status === 'fulfilled') {\n      console.log('⚡ 并行请求成功');\n      return successfulResult.value;\n    } else {\n      console.error('❌ 所有并行请求都失败了');\n      throw new Error('所有并行请求都失败了');\n    }\n    */\n  }\n\n  // 🎯 选择最佳连接\n  private selectBestConnection(): APIConnection {\n    const activeConnections = this.connections.filter(c => c.isActive);\n    \n    if (activeConnections.length === 0) {\n      throw new Error('没有可用的API连接');\n    }\n\n    // 基于性能选择连接\n    const bestConnection = activeConnections.reduce((best, current) => {\n      const bestScore = this.calculateConnectionScore(best);\n      const currentScore = this.calculateConnectionScore(current);\n      return currentScore > bestScore ? current : best;\n    });\n\n    return bestConnection;\n  }\n\n  // 📊 计算连接评分\n  private calculateConnectionScore(connection: APIConnection): number {\n    const successRate = connection.requestCount > 0 ? \n      (connection.requestCount - connection.errorCount) / connection.requestCount : 1;\n    \n    const responseTimeScore = connection.averageResponseTime > 0 ? \n      Math.max(0, 1 - connection.averageResponseTime / 10000) : 1; // 10秒为基准\n    \n    const recentUsageScore = Date.now() - connection.lastUsed > 5000 ? 1 : 0.5; // 5秒冷却\n    \n    return successRate * 0.5 + responseTimeScore * 0.3 + recentUsageScore * 0.2;\n  }\n\n  // 🌐 发起API请求\n  private async makeAPIRequest(connection: APIConnection, prompt: string, timeLimit: number): Promise<string> {\n    return this.makeAPIRequestWithConfig(connection, prompt, timeLimit, connection.config.temperature);\n  }\n\n  // 🌐 发起带配置的API请求\n  private async makeAPIRequestWithConfig(connection: APIConnection, prompt: string, timeLimit: number, temperature: number): Promise<string> {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => controller.abort(), timeLimit);\n\n    try {\n      const response = await fetch(`${connection.config.baseUrl}/v1/chat/completions`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${connection.config.apiKey}`\n        },\n        body: JSON.stringify({\n          model: connection.config.model,\n          messages: [\n            {\n              role: 'system',\n              content: '你是世界顶级的德州扑克AI，专注于快速、准确的决策。'\n            },\n            {\n              role: 'user',\n              content: prompt\n            }\n          ],\n          temperature: temperature, // 使用动态温度\n          max_tokens: connection.config.maxTokens,\n          stream: false\n        }),\n        signal: controller.signal\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(`API请求失败: ${response.status} ${response.statusText}`);\n      }\n\n      const data = await response.json();\n\n      if (!data.choices || !data.choices[0] || !data.choices[0].message) {\n        throw new Error('API响应格式错误');\n      }\n\n      return data.choices[0].message.content;\n\n    } catch (error) {\n      clearTimeout(timeoutId);\n\n      if (error.name === 'AbortError') {\n        throw new Error(`API请求超时 (${timeLimit}ms)`);\n      }\n\n      throw error;\n    }\n  }\n\n  // 🔍 解析AI响应\n  private parseAIResponse(responseText: string): AIDecision {\n    try {\n      // 尝试提取JSON\n      const jsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\n      if (!jsonMatch) {\n        throw new Error('响应中未找到JSON格式');\n      }\n\n      const jsonStr = jsonMatch[0];\n      const parsed = JSON.parse(jsonStr);\n\n      // 验证必需字段\n      if (!parsed.action || !['fold', 'check', 'call', 'bet', 'raise', 'all-in'].includes(parsed.action)) {\n        throw new Error('无效的行动类型');\n      }\n\n      // 构建标准决策对象\n      const decision: AIDecision = {\n        action: parsed.action === 'bet' ? 'raise' : parsed.action, // 统一bet为raise\n        amount: parsed.amount || 0,\n        confidence: parsed.confidence || 0.5,\n        reasoning: parsed.reasoning || '无推理信息',\n        decisionTime: 0, // 会在外层设置\n        metadata: {\n          handStrength: parsed.hand_strength || parsed.handStrength || 0.5,\n          positionFactor: parsed.position_factor || parsed.positionFactor || 'unknown',\n          opponentAdjustment: parsed.opponent_adjustment || parsed.opponentAdjustment || 'standard',\n          playType: parsed.play_type || parsed.playType || 'unknown'\n        }\n      };\n\n      console.log('✅ AI响应解析成功:', decision.action);\n      return decision;\n\n    } catch (error) {\n      console.error('❌ AI响应解析失败:', error);\n      console.log('原始响应:', responseText);\n      \n      // 返回安全的默认决策\n      return {\n        action: 'fold',\n        amount: 0,\n        confidence: 0.3,\n        reasoning: '响应解析失败，安全弃牌',\n        decisionTime: 0,\n        metadata: {\n          handStrength: 0,\n          positionFactor: 'unknown',\n          opponentAdjustment: 'error',\n          playType: 'emergency_fold'\n        }\n      };\n    }\n  }\n\n  // 🔄 尝试备用请求\n  private async tryBackupRequest(prompt: string, timeLimit: number, startTime: number): Promise<AIDecision> {\n    return this.tryBackupRequestWithConfig(prompt, timeLimit, this.connections[0]?.config.temperature || 0.1, startTime);\n  }\n\n  // 🔄 尝试带配置的备用请求\n  private async tryBackupRequestWithConfig(prompt: string, timeLimit: number, temperature: number, startTime: number): Promise<AIDecision> {\n    const remainingTime = Math.max(1000, timeLimit - (Date.now() - startTime));\n\n    // 尝试其他连接\n    const backupConnections = this.connections.filter(c => c.isActive);\n\n    for (const connection of backupConnections) {\n      try {\n        console.log(`🔄 尝试备用连接: ${connection.id} (温度: ${temperature})`);\n\n        const response = await this.makeAPIRequestWithConfig(connection, prompt, remainingTime, temperature);\n        const decision = this.parseAIResponse(response);\n\n        this.updateConnectionStats(connection, Date.now() - startTime, true);\n        return decision;\n\n      } catch (error) {\n        console.log(`❌ 备用连接失败: ${connection.id}`);\n        this.updateConnectionStats(connection, Date.now() - startTime, false);\n      }\n    }\n\n    // 所有连接都失败，返回紧急决策\n    console.error('❌ 所有API连接都失败了');\n    return this.getEmergencyDecision();\n  }\n\n  // 🚨 紧急决策\n  private getEmergencyDecision(): AIDecision {\n    return {\n      action: 'fold',\n      amount: 0,\n      confidence: 0.1,\n      reasoning: 'API连接失败，紧急弃牌',\n      decisionTime: 0,\n      metadata: {\n        handStrength: 0,\n        positionFactor: 'unknown',\n        opponentAdjustment: 'emergency',\n        playType: 'emergency_fold'\n      }\n    };\n  }\n\n  // 📊 更新连接统计\n  private updateConnectionStats(connection: APIConnection, responseTime: number, success: boolean): void {\n    connection.requestCount++;\n    connection.lastUsed = Date.now();\n\n    if (success) {\n      // 更新平均响应时间\n      connection.averageResponseTime = \n        (connection.averageResponseTime * (connection.requestCount - 1) + responseTime) / connection.requestCount;\n    } else {\n      connection.errorCount++;\n      \n      // 如果错误率过高，暂时禁用连接\n      const errorRate = connection.errorCount / connection.requestCount;\n      if (errorRate > 0.5 && connection.requestCount > 5) {\n        connection.isActive = false;\n        console.warn(`⚠️ 连接 ${connection.id} 错误率过高，暂时禁用`);\n        \n        // 5分钟后重新启用\n        setTimeout(() => {\n          connection.isActive = true;\n          connection.errorCount = 0;\n          console.log(`🔄 连接 ${connection.id} 重新启用`);\n        }, 300000);\n      }\n    }\n  }\n\n  // 🔄 队列处理器\n  private startQueueProcessor(): void {\n    setInterval(() => {\n      if (!this.isProcessingQueue && this.requestQueue.length > 0) {\n        this.processRequestQueue();\n      }\n    }, 100);\n  }\n\n  private async processRequestQueue(): Promise<void> {\n    if (this.requestQueue.length === 0) return;\n\n    this.isProcessingQueue = true;\n    \n    const request = this.requestQueue.shift()!;\n    \n    try {\n      const decision = await this.makeDecisionRequest(request.prompt, request.timeLimit);\n      request.resolve(decision);\n    } catch (error) {\n      request.reject(error);\n    }\n    \n    this.isProcessingQueue = false;\n  }\n\n  // 📊 获取连接池状态\n  getPoolStatus(): PoolStatus {\n    const activeConnections = this.connections.filter(c => c.isActive).length;\n    const totalRequests = this.connections.reduce((sum, c) => sum + c.requestCount, 0);\n    const totalErrors = this.connections.reduce((sum, c) => sum + c.errorCount, 0);\n    const averageResponseTime = this.connections.reduce((sum, c) => sum + c.averageResponseTime, 0) / this.connections.length;\n\n    return {\n      totalConnections: this.connections.length,\n      activeConnections,\n      totalRequests,\n      totalErrors,\n      successRate: totalRequests > 0 ? (totalRequests - totalErrors) / totalRequests : 1,\n      averageResponseTime,\n      queueLength: this.requestQueue.length\n    };\n  }\n\n  // 🧹 清理资源\n  cleanup(): void {\n    this.connections.forEach(connection => {\n      connection.isActive = false;\n    });\n    \n    this.requestQueue = [];\n    console.log('🧹 AI API连接池已清理');\n  }\n}\n\n// 🔧 辅助接口\ninterface PendingRequest {\n  prompt: string;\n  timeLimit: number;\n  resolve: (decision: AIDecision) => void;\n  reject: (error: Error) => void;\n}\n\nexport interface PoolStatus {\n  totalConnections: number;\n  activeConnections: number;\n  totalRequests: number;\n  totalErrors: number;\n  successRate: number;\n  averageResponseTime: number;\n  queueLength: number;\n}\n","import { NewGameState } from '../core/game-engine';\nimport { Card } from '../types/poker';\n\n// 📊 复杂度评估结果\nexport interface ComplexityAssessment {\n    totalScore: number;        // 总复杂度分数 (0-100)\n    category: 'simple' | 'medium' | 'complex' | 'extreme';\n    factors: {\n      handStrengthAmbiguity: number;    // 牌力模糊度 (0-25)\n      opponentRangeWidth: number;       // 对手范围宽度 (0-25) \n      actionSequenceComplexity: number; // 行动序列复杂度 (0-25)\n      stackAndPotDynamics: number;      // 筹码和底池动态 (0-25)\n    };\n    recommendedTimeout: number;         // 推荐超时时间(ms)\n    recommendedTemperature: number;     // 推荐AI温度\n    promptType: 'minimal' | 'standard' | 'detailed' | 'comprehensive';\n  }\n\n// 🎯 局势复杂度分析器\nexport class SituationComplexityAnalyzer {\n\n  // 🎯 主要分析入口\n  analyzeSituation(\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[]\n  ): ComplexityAssessment {\n\n    // 🚀 调试：检查gameState.phase\n    console.log('🔍 SituationComplexityAnalyzer收到的gameState:', {\n      phase: gameState.phase,\n      phaseType: typeof gameState.phase,\n      gameStateKeys: Object.keys(gameState),\n      hasPhase: 'phase' in gameState,\n      gameStateStructure: {\n        gameId: gameState.gameId,\n        phase: gameState.phase,\n        players: gameState.players?.length,\n        pot: gameState.pot\n      }\n    });\n\n    // 简化实现：基于游戏阶段的基础复杂度评估\n    let baseScore = 0;\n\n    // 根据游戏阶段设置基础分数\n    switch (gameState.phase) {\n      case 'preflop':\n        baseScore = 20; // 翻前相对简单\n        break;\n      case 'flop':\n        baseScore = 35; // 翻牌中等复杂\n        break;\n      case 'turn':\n        baseScore = 50; // 转牌较复杂\n        break;\n      case 'river':\n        baseScore = 65; // 河牌最复杂\n        break;\n      default:\n        baseScore = 30;\n    }\n\n    // 根据底池大小调整\n    const pot = gameState.pot || 0;\n    const bigBlind = gameState.bigBlind || 100;\n    const potBBs = pot / bigBlind;\n\n    if (potBBs > 20) baseScore += 15; // 大底池增加复杂度\n    else if (potBBs > 10) baseScore += 8;\n    else if (potBBs > 5) baseScore += 3;\n\n    // 根据对手数量调整\n    const activeOpponents = gameState.players.filter(p => p.isActive && p.id !== playerId).length;\n    if (activeOpponents >= 3) baseScore += 10; // 多人底池\n    else if (activeOpponents >= 2) baseScore += 5;\n\n    const totalScore = Math.min(baseScore, 100);\n\n    const factors = {\n      handStrengthAmbiguity: Math.floor(totalScore * 0.3),\n      opponentRangeWidth: Math.floor(totalScore * 0.25),\n      actionSequenceComplexity: Math.floor(totalScore * 0.25),\n      stackAndPotDynamics: Math.floor(totalScore * 0.2)\n    };\n\n    return {\n      totalScore,\n      category: this.categorizeComplexity(totalScore),\n      factors,\n      recommendedTimeout: this.getRecommendedTimeout(totalScore),\n      recommendedTemperature: this.getRecommendedTemperature(totalScore),\n      promptType: this.getPromptType(totalScore)\n    };\n  }\n\n  // 🏷️ 复杂度分类\n  private categorizeComplexity(score: number): 'simple' | 'medium' | 'complex' | 'extreme' {\n    if (score <= 25) return 'simple';\n    if (score <= 50) return 'medium';\n    if (score <= 75) return 'complex';\n    return 'extreme';\n  }\n\n  // ⏱️ 推荐超时时间 (临时放宽限制确保稳定性)\n  private getRecommendedTimeout(score: number): number {\n    if (score <= 25) return 15000;  // 15秒 - 简单局势\n    if (score <= 50) return 25000;  // 25秒 - 中等复杂度\n    if (score <= 75) return 35000;  // 35秒 - 复杂局势\n    return 45000; // 45秒 - 极复杂局势\n  }\n\n  // 🌡️ 推荐AI温度\n  private getRecommendedTemperature(score: number): number {\n    if (score <= 25) return 0.1;   // 简单局势，低温度\n    if (score <= 50) return 0.3;   // 中等复杂，中等温度\n    if (score <= 75) return 0.5;   // 复杂局势，较高温度\n    return 0.7; // 极复杂，高温度保持创造性\n  }\n\n  // 📝 推荐Prompt类型\n  private getPromptType(score: number): 'minimal' | 'standard' | 'detailed' | 'comprehensive' {\n    if (score <= 25) return 'minimal';\n    if (score <= 50) return 'standard';\n    if (score <= 75) return 'detailed';\n    return 'comprehensive';\n  }\n}\n","import { NewGameState } from '../core/game-engine';\nimport { Card } from '../types/poker';\nimport { AdaptivePromptManager } from './adaptive-prompt-manager.ts';\nimport { AIAPIPool } from './ai-api-pool.ts';\nimport { AIDecision, OpponentProfile } from './ai-player.ts';\nimport { SituationComplexityAnalyzer } from './situation-complexity-analyzer.ts';\n\n// 🎯 游戏数据结构\nexport interface GameData {\n  // 基础信息\n  position: string;\n  positionIndex: number;\n  holeCards: string;\n  myChips: number;\n  pot: number;\n  currentBet: number;\n  toCall: number;\n\n  // 牌面信息\n  board?: string;\n  boardTexture?: string;\n  drawHeavy?: boolean;\n\n  // 对手信息\n  activePlayers: number;\n  totalPlayers: number;\n  actionSequence: string;\n  opponentProfiles: OpponentProfileSummary[];\n  opponentRanges?: string;\n\n  // 赔率信息\n  potOdds: string;\n\n  // 行动历史\n  currentRoundActions?: string;\n  recentOpponentBehavior?: string;\n\n  // 时间信息\n  timeLimit: number;\n  phase: string;\n}\n\nexport interface OpponentProfileSummary {\n  name: string;\n  position: string;\n  vpip: number;\n  pfr: number;\n  aggression: number;\n  tendency: string;\n}\n\n// 🚀 决策层级\nexport enum DecisionLayer {\n  FAST_FILTER = 1,    // 快速过滤 (50ms)\n  STRATEGY_ANALYSIS = 2, // 策略分析 (1-3s)\n  FINE_TUNING = 3     // 精细调整 (200ms)\n}\n\n// 📊 决策缓存\nexport interface CachedDecision {\n  situationKey: string;\n  decision: AIDecision;\n  timestamp: number;\n  hitCount: number;\n  confidence: number;\n}\n\n// ⚡ 快速决策引擎\nexport class FastDecisionEngine {\n  private decisionCache: Map<string, CachedDecision> = new Map();\n  private apiPool: AIAPIPool;\n  private promptManager: PromptManager;\n  private performanceTracker: PerformanceTracker;\n  private complexityAnalyzer: SituationComplexityAnalyzer;\n  private adaptivePromptManager: AdaptivePromptManager;\n\n  constructor(apiConfig: any) {\n    const poolConfig = {\n      apiKey: apiConfig.apiKey,\n      baseUrl: apiConfig.baseUrl,\n      model: apiConfig.model,\n      temperature: 0.1,\n      maxTokens: 150,\n      timeout: 60000 // 60秒基础超时，给AI充分思考时间\n    };\n\n    this.apiPool = new AIAPIPool(poolConfig, 3); // 3个并行连接\n    this.promptManager = new PromptManager();\n    this.performanceTracker = new PerformanceTracker();\n    this.complexityAnalyzer = new SituationComplexityAnalyzer();\n    this.adaptivePromptManager = new AdaptivePromptManager();\n\n    console.log('⚡ 快速决策引擎初始化完成 (含智能复杂度分析)');\n  }\n\n  // 🎯 主决策入口\n  async makeDecision(\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[],\n    opponentProfiles: Map<string, OpponentProfile>,\n    timeLimit: number = 30000\n  ): Promise<AIDecision> {\n    const startTime = Date.now();\n\n    try {\n      // 🚀 翻前优先使用GTO查表 (0ms决策)\n      if (gameState.phase === 'preflop') {\n        console.log('⚡ 翻前阶段，使用GTO查表决策');\n\n        try {\n          const gtoDecision = await this.getGTOPreflopDecision(gameState, playerId, holeCards);\n          if (gtoDecision) {\n            const totalTime = Date.now() - startTime;\n            console.log(`⚡ GTO翻前决策完成: ${gtoDecision.action} (${totalTime}ms)`);\n            return gtoDecision;\n          }\n        } catch (gtoError) {\n          console.warn('⚠️ GTO决策失败，回退到AI决策:', gtoError);\n        }\n      }\n\n      // 构建游戏数据\n      const gameData = this.buildGameData(gameState, playerId, holeCards, opponentProfiles, timeLimit);\n\n      // 三层决策架构\n      const decision = await this.executeLayeredDecision(gameData, gameState, playerId, holeCards);\n\n      // 记录性能\n      const totalTime = Date.now() - startTime;\n      this.performanceTracker.recordDecision(playerId, totalTime, decision.confidence);\n\n      console.log(`⚡ 决策完成: ${decision.action} (${totalTime}ms)`);\n\n      return decision;\n\n    } catch (error) {\n      console.error('❌ 决策引擎错误:', error);\n\n      // 返回安全的默认决策\n      return this.getEmergencyDecision(gameState, holeCards);\n    }\n  }\n\n  // 🏗️ 构建游戏数据\n  private buildGameData(\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[],\n    opponentProfiles: Map<string, OpponentProfile>,\n    timeLimit: number\n  ): GameData {\n    const player = gameState.players.find(p => p.id === playerId);\n    if (!player) throw new Error('玩家不存在');\n\n    const position = this.getPlayerPosition(gameState, playerId);\n    const positionIndex = gameState.players.findIndex(p => p.id === playerId);\n\n    // 构建对手档案摘要\n    const opponentSummaries: OpponentProfileSummary[] = [];\n    gameState.players.forEach(p => {\n      if (p.id !== playerId) {\n        const profile = opponentProfiles.get(p.id);\n        if (profile) {\n          opponentSummaries.push({\n            name: p.name,\n            position: this.getPlayerPosition(gameState, p.id),\n            vpip: profile.vpip,\n            pfr: profile.pfr,\n            aggression: profile.aggression,\n            tendency: profile.tendency\n          });\n        }\n      }\n    });\n\n    // 构建行动序列\n    const actionSequence = this.buildActionSequence(gameState);\n\n    // 计算底池赔率\n    const toCall = Math.max(0, gameState.currentBet - (player.currentBet || 0));\n    const potOdds = toCall > 0 ? `${(gameState.pot / toCall).toFixed(1)}:1` : 'N/A';\n\n    return {\n      position,\n      positionIndex,\n      holeCards: this.formatCards(holeCards),\n      myChips: player.chips,\n      pot: gameState.pot,\n      currentBet: gameState.currentBet,\n      toCall,\n      activePlayers: gameState.players.filter(p => p.isActive).length,\n      totalPlayers: gameState.players.length,\n      actionSequence,\n      opponentProfiles: opponentSummaries,\n      potOdds,\n      timeLimit,\n      phase: gameState.phase,\n\n      // 翻牌后信息\n      ...(gameState.phase !== 'preflop' && {\n        board: this.formatCards(gameState.communityCards),\n        boardTexture: this.analyzeBoardTexture(gameState.communityCards),\n        drawHeavy: this.isDrawHeavyBoard(gameState.communityCards),\n        currentRoundActions: this.buildCurrentRoundActions(gameState),\n        recentOpponentBehavior: this.buildOpponentBehaviorSummary(opponentProfiles)\n      })\n    };\n  }\n\n  // 🎯 执行分层决策\n  private async executeLayeredDecision(\n    gameData: GameData,\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[]\n  ): Promise<AIDecision> {\n    console.log('🚀 强制使用AI API决策 - 跳过缓存和明显决策');\n\n    // 直接进行策略分析 (强制使用API)\n    const strategicDecision = await this.performStrategicAnalysis(gameData, gameState, playerId, holeCards);\n\n    // Layer 3: 精细调整\n    const finalDecision = this.applyFineTuning(strategicDecision, gameData);\n\n    return finalDecision;\n  }\n\n  // ⚡ 尝试快速决策\n  private async tryQuickDecision(gameData: GameData): Promise<AIDecision | null> {\n    const startTime = Date.now();\n\n    // 检查缓存\n    const cachedDecision = this.checkDecisionCache(gameData);\n    if (cachedDecision) {\n      console.log('🎯 缓存命中');\n      return cachedDecision.decision;\n    }\n\n    // 明显的决策情况\n    const obviousDecision = this.checkObviousDecisions(gameData);\n    if (obviousDecision) {\n      console.log('🎯 明显决策');\n      return obviousDecision;\n    }\n\n    const elapsed = Date.now() - startTime;\n    if (elapsed > 50) {\n      console.log(`⚠️ 快速决策超时: ${elapsed}ms`);\n    }\n\n    return null;\n  }\n\n  // 🧠 执行策略分析\n  private async performStrategicAnalysis(\n    gameData: GameData,\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[]\n  ): Promise<AIDecision> {\n    const startTime = Date.now();\n\n    try {\n      // 🎯 分析局势复杂度\n      const complexityAssessment = this.complexityAnalyzer.analyzeSituation(\n        gameState,\n        playerId,\n        holeCards\n      );\n\n      console.log(`🎯 局势复杂度: ${complexityAssessment.category} (${complexityAssessment.totalScore}/100)`);\n      console.log(`📊 推荐: 超时${complexityAssessment.recommendedTimeout}ms, 温度${complexityAssessment.recommendedTemperature}, Prompt${complexityAssessment.promptType}`);\n\n      // 🚀 使用动态超时和温度 (临时放宽限制)\n      const maxAllowedTimeout = 50000; // 临时最大50秒超时\n      const dynamicTimeLimit = Math.min(\n        complexityAssessment.recommendedTimeout,\n        gameData.timeLimit - 500,\n        maxAllowedTimeout\n      );\n\n      // 📝 生成自适应Prompt\n      const adaptivePrompt = this.adaptivePromptManager.generatePrompt(\n        gameState,\n        playerId,\n        holeCards,\n        complexityAssessment.promptType,\n        dynamicTimeLimit,\n        complexityAssessment.recommendedTemperature\n      );\n\n      console.log(`🧠 发起智能AI决策请求 (时限: ${dynamicTimeLimit}ms, 温度: ${complexityAssessment.recommendedTemperature})`);\n\n      // 🚀 使用动态配置的API请求\n      const decision = await this.apiPool.makeDecisionRequestWithConfig(\n        adaptivePrompt,\n        dynamicTimeLimit,\n        complexityAssessment.recommendedTemperature\n      );\n      console.log('⚡ 智能AI决策请求成功');\n\n      // 设置决策时间和复杂度信息\n      decision.decisionTime = Date.now() - startTime;\n      decision.metadata = {\n        ...decision.metadata,\n        complexityScore: complexityAssessment.totalScore,\n        complexityCategory: complexityAssessment.category,\n        promptType: complexityAssessment.promptType\n      };\n\n      // 缓存决策\n      this.cacheDecision(gameData, decision);\n\n      const elapsed = Date.now() - startTime;\n      console.log(`🧠 智能策略分析完成: ${elapsed}ms, 决策: ${decision.action}, 复杂度: ${complexityAssessment.category}`);\n\n      return decision;\n\n    } catch (error) {\n      console.error('❌ 策略分析失败:', error);\n\n      // 回退到基础决策\n      const fallbackDecision = this.getBasicDecision(gameData);\n      fallbackDecision.decisionTime = Date.now() - startTime;\n      fallbackDecision.reasoning += ' (AI失败回退)';\n\n      return fallbackDecision;\n    }\n  }\n\n  // 🎨 应用精细调整\n  private applyFineTuning(decision: AIDecision, gameData: GameData): AIDecision {\n    const startTime = Date.now();\n\n    // 随机化处理（避免被读牌）\n    if (decision.action === 'raise' && Math.random() < 0.1) {\n      // 10%概率调整下注尺寸\n      decision.amount = Math.floor(decision.amount * (0.8 + Math.random() * 0.4));\n    }\n\n    // 位置调整\n    if (gameData.position === 'BTN' && decision.action === 'call') {\n      // 按钮位置更激进\n      if (Math.random() < 0.2) {\n        decision.action = 'raise';\n        decision.amount = gameData.currentBet * 2.5;\n        decision.reasoning += ' (按钮位置加注)';\n      }\n    }\n\n    // 筹码深度调整\n    const stackBB = gameData.myChips / 100; // 转换为大盲倍数\n    if (stackBB < 20 && decision.action === 'call') {\n      // 短筹码更激进\n      decision.action = 'raise';\n      decision.amount = gameData.myChips; // 全押\n      decision.reasoning += ' (短筹码全押)';\n    }\n\n    const elapsed = Date.now() - startTime;\n    console.log(`🎨 精细调整完成: ${elapsed}ms`);\n\n    return decision;\n  }\n\n  // 🎯 检查明显决策\n  private checkObviousDecisions(gameData: GameData): AIDecision | null {\n    // 超强牌\n    if (this.isNutsHand(gameData.holeCards, gameData.board)) {\n      return {\n        action: 'raise',\n        amount: gameData.pot * 0.8,\n        confidence: 0.95,\n        reasoning: '超强牌价值下注',\n        decisionTime: 50,\n        metadata: {\n          handStrength: 0.95,\n          positionFactor: gameData.position,\n          opponentAdjustment: 'value',\n          playType: 'value'\n        }\n      };\n    }\n\n    // 垃圾牌面对大注\n    if (this.isTrashHand(gameData.holeCards) && gameData.toCall > gameData.pot * 0.5) {\n      return {\n        action: 'fold',\n        amount: 0,\n        confidence: 0.9,\n        reasoning: '垃圾牌面对大注',\n        decisionTime: 50,\n        metadata: {\n          handStrength: 0.1,\n          positionFactor: gameData.position,\n          opponentAdjustment: 'fold',\n          playType: 'fold'\n        }\n      };\n    }\n\n    // 免费看牌\n    if (gameData.toCall === 0) {\n      return {\n        action: 'check',\n        amount: 0,\n        confidence: 0.8,\n        reasoning: '免费看牌',\n        decisionTime: 50,\n        metadata: {\n          handStrength: 0.5,\n          positionFactor: gameData.position,\n          opponentAdjustment: 'standard',\n          playType: 'check'\n        }\n      };\n    }\n\n    return null;\n  }\n\n  // 💾 检查决策缓存\n  private checkDecisionCache(gameData: GameData): CachedDecision | null {\n    const situationKey = this.generateSituationKey(gameData);\n    const cached = this.decisionCache.get(situationKey);\n\n    if (cached && Date.now() - cached.timestamp < 300000) { // 5分钟有效期\n      cached.hitCount++;\n      return cached;\n    }\n\n    return null;\n  }\n\n  // 💾 缓存决策\n  private cacheDecision(gameData: GameData, decision: AIDecision): void {\n    const situationKey = this.generateSituationKey(gameData);\n\n    this.decisionCache.set(situationKey, {\n      situationKey,\n      decision: { ...decision },\n      timestamp: Date.now(),\n      hitCount: 0,\n      confidence: decision.confidence\n    });\n\n    // 限制缓存大小\n    if (this.decisionCache.size > 1000) {\n      const oldestKey = Array.from(this.decisionCache.keys())[0];\n      this.decisionCache.delete(oldestKey);\n    }\n  }\n\n  // 🔑 生成情况键\n  private generateSituationKey(gameData: GameData): string {\n    const handStrength = this.calculateHandStrength(gameData.holeCards);\n    const positionGroup = this.getPositionGroup(gameData.position);\n    const actionType = this.getActionType(gameData.actionSequence);\n    const potOddsGroup = this.getPotOddsGroup(gameData.potOdds);\n\n    return `${handStrength}_${positionGroup}_${actionType}_${potOddsGroup}_${gameData.phase}`;\n  }\n\n  // 🚀 GTO翻前决策\n  private async getGTOPreflopDecision(\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[]\n  ): Promise<AIDecision | null> {\n    try {\n      // 动态导入GTO服务 (避免循环依赖)\n      const { gtoService } = await import('../services/gto-service.ts');\n\n      // 找到当前玩家\n      const currentPlayer = gameState.players.find(p => p.id === playerId);\n      if (!currentPlayer) {\n        throw new Error('找不到当前玩家');\n      }\n\n      // 格式化手牌\n      const hand = gtoService.formatHoleCards(holeCards);\n      if (hand === 'XX') {\n        throw new Error('无效手牌');\n      }\n\n      // 格式化位置\n      const position = gtoService.formatPosition(\n        currentPlayer.position,\n        gameState.players.length,\n        gameState.dealerIndex\n      );\n\n      // 计算筹码深度\n      const stackBB = gtoService.calculateStackDepth(\n        currentPlayer.chips,\n        gameState.bigBlind || 100\n      );\n\n      // 分析面对的行动\n      const facingAction = gtoService.analyzeFacingAction(gameState, playerId);\n\n      // 计算后面的玩家数量\n      const playersBehind = gtoService.calculatePlayersBehind(gameState, playerId);\n\n      // 构建GTO查询\n      const gtoQuery = {\n        hand,\n        position,\n        facing_action: facingAction,\n        players_behind: playersBehind,\n        stack_bb: stackBB\n      };\n\n      console.log(`🔍 GTO查询: ${JSON.stringify(gtoQuery)}`);\n\n      // 获取GTO决策 (带超时保护)\n      const gtoDecision = await Promise.race([\n        gtoService.getPreflopDecision(gtoQuery),\n        new Promise<never>((_, reject) =>\n          setTimeout(() => reject(new Error('GTO决策超时')), 8000)\n        )\n      ]);\n\n      // 转换为AI决策格式\n      const aiDecision: AIDecision = {\n        action: gtoDecision.action as any,\n        amount: this.calculateGTOAmount(gtoDecision, gameState),\n        confidence: gtoDecision.frequency,\n        reasoning: `GTO翻前策略: ${gtoDecision.reasoning}`,\n        decisionTime: 0,\n        metadata: {\n          handStrength: this.getHandStrengthFromTier(gtoDecision.hand_tier),\n          positionFactor: currentPlayer.position,\n          opponentAdjustment: 'gto',\n          playType: 'gto_preflop',\n          gtoData: gtoDecision\n        }\n      };\n\n      return aiDecision;\n\n    } catch (error) {\n      console.error('❌ GTO翻前决策失败:', error);\n      return null;\n    }\n  }\n\n  // 计算GTO决策的具体金额\n  private calculateGTOAmount(gtoDecision: any, gameState: NewGameState): number {\n    const bigBlind = gameState.bigBlind || 100;\n\n    switch (gtoDecision.action) {\n      case 'fold':\n        return 0;\n      case 'call':\n        return gameState.currentBet;\n      case 'limp':\n        return bigBlind;\n      case 'raise':\n        return Math.round(gtoDecision.amount * bigBlind);\n      case 'all_in':\n        // 返回一个很大的数字表示全下\n        return 999999;\n      default:\n        return 0;\n    }\n  }\n\n  // 从手牌等级获取强度值\n  private getHandStrengthFromTier(tier: string): number {\n    const tierMap: Record<string, number> = {\n      'PREMIUM': 0.95,\n      'STRONG': 0.8,\n      'MEDIUM': 0.6,\n      'WEAK': 0.4,\n      'SPECULATIVE': 0.3,\n      'TRASH': 0.1,\n      'UNKNOWN': 0.5\n    };\n\n    return tierMap[tier] || 0.5;\n  }\n\n  // 🚨 紧急决策\n  private getEmergencyDecision(gameState: NewGameState, holeCards: Card[]): AIDecision {\n    return {\n      action: 'fold',\n      amount: 0,\n      confidence: 0.5,\n      reasoning: '系统错误，安全弃牌',\n      decisionTime: 0,\n      metadata: {\n        handStrength: 0,\n        positionFactor: 'unknown',\n        opponentAdjustment: 'emergency',\n        playType: 'emergency_fold'\n      }\n    };\n  }\n\n  // 🎯 基础决策\n  private getBasicDecision(gameData: GameData): AIDecision {\n    const handStrength = this.calculateHandStrength(gameData.holeCards);\n\n    if (handStrength > 0.7) {\n      return {\n        action: 'raise',\n        amount: Math.round(Math.max(gameData.currentBet * 2, 100)),\n        confidence: 0.7,\n        reasoning: '强牌基础策略',\n        decisionTime: 1000,\n        metadata: {\n          handStrength,\n          positionFactor: gameData.position,\n          opponentAdjustment: 'basic',\n          playType: 'value'\n        }\n      };\n    } else if (handStrength > 0.4 && gameData.toCall < gameData.pot * 0.3) {\n      return {\n        action: 'call',\n        amount: gameData.toCall,\n        confidence: 0.6,\n        reasoning: '中等牌力跟注',\n        decisionTime: 1000,\n        metadata: {\n          handStrength,\n          positionFactor: gameData.position,\n          opponentAdjustment: 'basic',\n          playType: 'call'\n        }\n      };\n    } else {\n      return {\n        action: 'fold',\n        amount: 0,\n        confidence: 0.8,\n        reasoning: '牌力不足弃牌',\n        decisionTime: 1000,\n        metadata: {\n          handStrength,\n          positionFactor: gameData.position,\n          opponentAdjustment: 'basic',\n          playType: 'fold'\n        }\n      };\n    }\n  }\n\n  // 🔧 辅助方法\n  private getPlayerPosition(gameState: NewGameState, playerId: string): string {\n    const playerIndex = gameState.players.findIndex(p => p.id === playerId);\n    const dealerIndex = gameState.dealerIndex;\n    const totalPlayers = gameState.players.length;\n\n    // 计算相对于庄家的位置\n    const positionIndex = (playerIndex - dealerIndex + totalPlayers) % totalPlayers;\n\n    // 9人桌标准位置顺序：庄家开始顺时针\n    // 位置0: BTN, 位置1: SB, 位置2: BB, 位置3: UTG, 位置4: UTG+1, 位置5: UTG+2, 位置6: MP, 位置7: MP+1, 位置8: CO\n    const positions = ['BTN', 'SB', 'BB', 'UTG', 'UTG+1', 'UTG+2', 'MP', 'MP+1', 'CO'];\n\n    console.log(`🔍 位置计算: 玩家${playerId} playerIndex=${playerIndex}, dealerIndex=${dealerIndex}, positionIndex=${positionIndex}, 位置=${positions[positionIndex]}`);\n\n    return positions[positionIndex] || `POS${positionIndex}`;\n  }\n\n  private formatCards(cards: Card[]): string {\n    return cards.map(card => `${card.rank}${card.suit}`).join(' ');\n  }\n\n  private buildActionSequence(gameState: NewGameState): string {\n    if (!gameState.currentRoundActions || gameState.currentRoundActions.length === 0) {\n      return '游戏开始';\n    }\n\n    return gameState.currentRoundActions\n      .map(action => `${action.playerName}:${action.action}${action.amount ? `(${action.amount})` : ''}`)\n      .join(' → ');\n  }\n\n  private buildCurrentRoundActions(gameState: NewGameState): string {\n    if (!gameState.currentRoundActions || gameState.currentRoundActions.length === 0) {\n      return '本轮暂无行动';\n    }\n\n    return gameState.currentRoundActions\n      .filter(action => action.phase === gameState.phase)\n      .map(action => `${action.playerName} ${action.action} ${action.amount || ''}`)\n      .join(', ');\n  }\n\n  private buildOpponentBehaviorSummary(opponentProfiles: Map<string, OpponentProfile>): string {\n    const summaries: string[] = [];\n    opponentProfiles.forEach(profile => {\n      const recentActions = profile.recentActions.slice(-3);\n      if (recentActions.length > 0) {\n        summaries.push(`${profile.playerName}: ${recentActions.map(a => a.action).join(',')}`);\n      }\n    });\n    return summaries.join('; ');\n  }\n\n  private analyzeBoardTexture(communityCards: Card[]): string {\n    if (communityCards.length === 0) return 'preflop';\n\n    // 简化的牌面纹理分析\n    const suits = communityCards.map(c => c.suit);\n    const ranks = communityCards.map(c => c.rank);\n\n    const isFlushDraw = suits.some(suit => suits.filter(s => s === suit).length >= 2);\n    const isStraightDraw = this.hasStraightDraw(ranks);\n\n    if (isFlushDraw && isStraightDraw) return 'wet';\n    if (isFlushDraw || isStraightDraw) return 'semi-wet';\n    return 'dry';\n  }\n\n  private isDrawHeavyBoard(communityCards: Card[]): boolean {\n    return this.analyzeBoardTexture(communityCards) === 'wet';\n  }\n\n  private hasStraightDraw(ranks: string[]): boolean {\n    // 简化实现\n    const values = ranks.map(r => this.getCardRankValue(r)).sort((a, b) => a - b);\n    for (let i = 0; i < values.length - 1; i++) {\n      if (values[i + 1] - values[i] === 1) return true;\n    }\n    return false;\n  }\n\n  private calculateHandStrength(holeCardsStr: string): number {\n    // 简化的手牌强度计算\n    const cards = holeCardsStr.split(' ');\n    if (cards.length !== 2) return 0.5;\n\n    const [card1, card2] = cards;\n    const rank1 = this.getCardRankValue(card1[0]);\n    const rank2 = this.getCardRankValue(card2[0]);\n    const suited = card1[1] === card2[1];\n\n    let strength = Math.max(rank1, rank2) / 14;\n\n    if (rank1 === rank2) strength += 0.3; // 对子加成\n    if (suited) strength += 0.1; // 同花加成\n\n    return Math.min(strength, 1);\n  }\n\n  private getCardRankValue(rank: string): number {\n    const values: { [key: string]: number } = {\n      '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,\n      'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14\n    };\n    return values[rank] || 0;\n  }\n\n  private isNutsHand(holeCards: string, board?: string): boolean {\n    // 简化实现 - 检查是否是超强牌\n    const handStrength = this.calculateHandStrength(holeCards);\n    return handStrength > 0.9;\n  }\n\n  private isTrashHand(holeCards: string): boolean {\n    const handStrength = this.calculateHandStrength(holeCards);\n    return handStrength < 0.2;\n  }\n\n  private getPositionGroup(position: string): string {\n    if (['UTG', 'UTG+1', 'UTG+2'].includes(position)) return 'early';\n    if (['MP', 'MP+1'].includes(position)) return 'middle';\n    return 'late';\n  }\n\n  private getActionType(actionSequence: string): string {\n    if (actionSequence.includes('raise') || actionSequence.includes('bet')) return 'aggressive';\n    if (actionSequence.includes('call')) return 'passive';\n    return 'unopened';\n  }\n\n  private getPotOddsGroup(potOdds: string): string {\n    const odds = parseFloat(potOdds.split(':')[0]);\n    if (odds > 3) return 'good';\n    if (odds > 2) return 'fair';\n    return 'poor';\n  }\n}\n\n// 🎯 Prompt管理器\nclass PromptManager {\n  generateDecisionPrompt(gameData: GameData): string {\n    if (gameData.phase === 'preflop') {\n      return this.generatePreflopPrompt(gameData);\n    } else {\n      return this.generatePostflopPrompt(gameData);\n    }\n  }\n\n  private generatePreflopPrompt(gameData: GameData): string {\n    return `你是PokerGPT-Pro，世界顶级德州扑克AI。当前9人桌，盲注50/100。\n\n**当前局面** (翻牌前):\n位置: ${gameData.position} (${gameData.positionIndex}/9)\n手牌: ${gameData.holeCards}\n筹码: ${gameData.myChips} (${(gameData.myChips/100).toFixed(1)}BB)\n底池: ${gameData.pot}\n当前下注: ${gameData.currentBet}\n需要跟注: ${gameData.toCall}\n\n**行动序列**: ${gameData.actionSequence}\n**活跃玩家**: ${gameData.activePlayers}/${gameData.totalPlayers}\n\n**对手档案**:\n${gameData.opponentProfiles.map(p =>\n  `${p.name}(${p.position}): VPIP${p.vpip}% PFR${p.pfr}% 激进度${p.aggression}/10 ${p.tendency}`\n).join('\\n')}\n\n**快速分析要求**:\n1. 手牌强度评级(1-10)\n2. 位置优势评估\n3. 对手行为读取\n4. 底池赔率计算\n5. GTO基础策略+对手调整\n\n**时间限制**: ${gameData.timeLimit}ms内决策\n\n返回格式:\n{\n  \"action\": \"fold/call/raise\",\n  \"amount\": 数字,\n  \"confidence\": 0.8,\n  \"reasoning\": \"简洁推理(20字内)\",\n  \"hand_strength\": 7,\n  \"position_factor\": \"early/middle/late\",\n  \"opponent_adjustment\": \"tighter/standard/looser\"\n}`;\n  }\n\n  private generatePostflopPrompt(gameData: GameData): string {\n    return `PokerGPT-Pro翻牌后分析 - 9人桌盲注50/100\n\n**牌面信息**:\n手牌: ${gameData.holeCards}\n公共牌: ${gameData.board}\n牌面纹理: ${gameData.boardTexture} (${gameData.drawHeavy ? '听牌多' : '听牌少'})\n\n**当前状况**:\n位置: ${gameData.position} (${gameData.positionIndex}/9)\n底池: ${gameData.pot} (${(gameData.pot/100).toFixed(1)}BB)\n筹码: ${gameData.myChips} (${(gameData.myChips/100).toFixed(1)}BB)\n当前下注: ${gameData.currentBet}\n需要跟注: ${gameData.toCall}\n底池赔率: ${gameData.potOdds}\n\n**本轮行动**: ${gameData.currentRoundActions}\n**对手行为模式**: ${gameData.recentOpponentBehavior}\n\n**快速评估**:\n1. 牌力等级(nuts/strong/medium/weak/air)\n2. 听牌可能性\n3. 对手可能范围\n4. 价值下注vs诈唬平衡\n5. 对手倾向调整\n\n**时间限制**: ${gameData.timeLimit}ms内决策\n\n返回:\n{\n  \"action\": \"fold/check/call/bet/raise\",\n  \"amount\": 数字,\n  \"confidence\": 0.85,\n  \"reasoning\": \"简洁推理\",\n  \"hand_category\": \"strong\",\n  \"opponent_likely_range\": \"medium-strong\",\n  \"play_type\": \"value/bluff/protection\"\n}`;\n  }\n}\n\n// 📊 性能追踪器\nclass PerformanceTracker {\n  private playerMetrics: Map<string, PlayerMetrics> = new Map();\n\n  recordDecision(playerId: string, time: number, confidence: number): void {\n    let metrics = this.playerMetrics.get(playerId);\n    if (!metrics) {\n      metrics = {\n        totalDecisions: 0,\n        totalTime: 0,\n        averageTime: 0,\n        averageConfidence: 0,\n        fastDecisions: 0, // <1秒\n        slowDecisions: 0  // >10秒\n      };\n      this.playerMetrics.set(playerId, metrics);\n    }\n\n    metrics.totalDecisions++;\n    metrics.totalTime += time;\n    metrics.averageTime = metrics.totalTime / metrics.totalDecisions;\n    metrics.averageConfidence =\n      (metrics.averageConfidence * (metrics.totalDecisions - 1) + confidence) / metrics.totalDecisions;\n\n    if (time < 1000) metrics.fastDecisions++;\n    if (time > 10000) metrics.slowDecisions++;\n\n    console.log(`📊 性能记录: ${playerId} - ${time}ms, 信心度: ${confidence.toFixed(2)}`);\n  }\n\n  getPlayerMetrics(playerId: string): PlayerMetrics | undefined {\n    return this.playerMetrics.get(playerId);\n  }\n\n  getAllMetrics(): Map<string, PlayerMetrics> {\n    return new Map(this.playerMetrics);\n  }\n}\n\ninterface PlayerMetrics {\n  totalDecisions: number;\n  totalTime: number;\n  averageTime: number;\n  averageConfidence: number;\n  fastDecisions: number;\n  slowDecisions: number;\n}\n"],"names":["AdaptivePromptManager","generatePrompt","gameState","playerId","holeCards","complexityLevel","timeLimit","temperature","this","generateMinimalPrompt","generateStandardPrompt","generateDetailedPrompt","generateComprehensivePrompt","player","players","find","p","id","rank","suit","pot","getAmountToCall","chips","phase","getBoardString","communityCards","handStr","position","getPlayerPosition","opponents","getActiveOpponents","length","actionHistory","getActionHistory","potOdds","calculatePotOdds","getStackSizes","Math","round","bigBlind","calculateSPR","slice","map","a","action","amount","join","boardTexture","analyzeBoardTexture","opponentProfiles","getOpponentProfiles","gameFlow","analyzeGameFlow","getPositionDetails","texture","draws","danger","name","style","vpip","pfr","calculateImpliedOdds","calculateReverseImpliedOdds","preflop","postflop","aggression","c","filter","isActive","AIAPIPool","constructor","apiConfig","poolSize","arguments","undefined","connections","currentConnectionIndex","requestQueue","isProcessingQueue","initializeConnections","startQueueProcessor","console","log","baseConfig","i","connection","config","requestCount","errorCount","averageResponseTime","lastUsed","push","makeDecisionRequest","prompt","_this$connections$","makeDecisionRequestWithConfig","startTime","Date","now","selectBestConnection","response","makeAPIRequestWithConfig","decision","parseAIResponse","updateConnectionStats","error","tryBackupRequestWithConfig","makeParallelRequest","Error","activeConnections","reduce","best","current","bestScore","calculateConnectionScore","max","makeAPIRequest","controller","AbortController","timeoutId","setTimeout","abort","fetch","baseUrl","method","headers","apiKey","body","JSON","stringify","model","messages","role","content","max_tokens","maxTokens","stream","signal","clearTimeout","ok","status","statusText","data","json","choices","message","responseText","jsonMatch","match","jsonStr","parsed","parse","includes","confidence","reasoning","decisionTime","metadata","handStrength","hand_strength","positionFactor","position_factor","opponentAdjustment","opponent_adjustment","playType","play_type","tryBackupRequest","_this$connections$2","remainingTime","backupConnections","getEmergencyDecision","responseTime","success","warn","setInterval","processRequestQueue","request","shift","resolve","reject","getPoolStatus","totalRequests","sum","totalErrors","totalConnections","successRate","queueLength","cleanup","forEach","SituationComplexityAnalyzer","analyzeSituation","_gameState$players","phaseType","gameStateKeys","Object","keys","hasPhase","gameStateStructure","gameId","baseScore","potBBs","activeOpponents","totalScore","min","factors","handStrengthAmbiguity","floor","opponentRangeWidth","actionSequenceComplexity","stackAndPotDynamics","category","categorizeComplexity","recommendedTimeout","getRecommendedTimeout","recommendedTemperature","getRecommendedTemperature","promptType","getPromptType","score","FastDecisionEngine","decisionCache","Map","apiPool","promptManager","performanceTracker","complexityAnalyzer","adaptivePromptManager","poolConfig","timeout","PromptManager","PerformanceTracker","makeDecision","gtoDecision","getGTOPreflopDecision","totalTime","gtoError","gameData","buildGameData","executeLayeredDecision","recordDecision","positionIndex","findIndex","opponentSummaries","profile","get","tendency","actionSequence","buildActionSequence","toCall","currentBet","toFixed","formatCards","myChips","activePlayers","totalPlayers","board","drawHeavy","isDrawHeavyBoard","currentRoundActions","buildCurrentRoundActions","recentOpponentBehavior","buildOpponentBehaviorSummary","strategicDecision","performStrategicAnalysis","applyFineTuning","tryQuickDecision","cachedDecision","checkDecisionCache","obviousDecision","checkObviousDecisions","elapsed","complexityAssessment","maxAllowedTimeout","dynamicTimeLimit","adaptivePrompt","complexityScore","complexityCategory","cacheDecision","fallbackDecision","getBasicDecision","random","isNutsHand","isTrashHand","situationKey","generateSituationKey","cached","timestamp","hitCount","set","size","oldestKey","Array","from","delete","calculateHandStrength","getPositionGroup","getActionType","getPotOddsGroup","gtoService","currentPlayer","hand","formatHoleCards","formatPosition","dealerIndex","stackBB","calculateStackDepth","facingAction","analyzeFacingAction","gtoQuery","facing_action","players_behind","calculatePlayersBehind","stack_bb","Promise","race","getPreflopDecision","_","calculateGTOAmount","frequency","getHandStrengthFromTier","hand_tier","gtoData","tier","playerIndex","positions","cards","card","playerName","summaries","recentActions","suits","ranks","isFlushDraw","some","s","isStraightDraw","hasStraightDraw","values","r","getCardRankValue","sort","b","holeCardsStr","split","card1","card2","rank1","rank2","suited","strength","odds","parseFloat","generateDecisionPrompt","generatePreflopPrompt","generatePostflopPrompt","playerMetrics","time","metrics","totalDecisions","averageTime","averageConfidence","fastDecisions","slowDecisions","getPlayerMetrics","getAllMetrics"],"sourceRoot":""}