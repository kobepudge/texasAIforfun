{"version":3,"file":"static/js/113.336dff49.chunk.js","mappings":"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","sources":["ai/adaptive-prompt-manager.ts","ai/ai-api-pool.ts","ai/situation-complexity-analyzer.ts","ai/fast-decision-engine.ts"],"sourcesContent":["import { NewGameState } from '../core/game-engine';\nimport { Card } from '../types/poker';\n\n// 🎯 自适应Prompt管理器\nexport class AdaptivePromptManager {\n  \n  // 📝 根据复杂度生成对应的Prompt\n  generatePrompt(\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[],\n    complexityLevel: 'minimal' | 'standard' | 'detailed' | 'comprehensive',\n    timeLimit: number,\n    temperature: number\n  ): string {\n    \n    switch (complexityLevel) {\n      case 'minimal':\n        return this.generateMinimalPrompt(gameState, playerId, holeCards, timeLimit);\n      case 'standard':\n        return this.generateStandardPrompt(gameState, playerId, holeCards, timeLimit);\n      case 'detailed':\n        return this.generateDetailedPrompt(gameState, playerId, holeCards, timeLimit, temperature);\n      case 'comprehensive':\n        return this.generateComprehensivePrompt(gameState, playerId, holeCards, timeLimit, temperature);\n      default:\n        return this.generateStandardPrompt(gameState, playerId, holeCards, timeLimit);\n    }\n  }\n\n  // ⚡ 极简Prompt - 用于明显决策\n  private generateMinimalPrompt(\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[],\n    timeLimit: number\n  ): string {\n    const player = gameState.players.find(p => p.id === playerId);\n    const handStr = `${holeCards[0].rank}${holeCards[0].suit} ${holeCards[1].rank}${holeCards[1].suit}`;\n    const pot = gameState.pot;\n    const toCall = this.getAmountToCall(gameState, playerId);\n    const stack = player?.chips || 0;\n    const board = this.getBoardString(gameState.communityCards);\n\n    return `OBVIOUS: ${handStr} vs ${board}, Pot:${pot}, Call:${toCall}, Stack:${stack}\n→ {\"action\":\"fold/check/call/raise/all-in\",\"amount\":0,\"confidence\":0.9}`;\n  }\n\n  // 📊 标准Prompt - 用于常规决策\n  private generateStandardPrompt(\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[],\n    timeLimit: number\n  ): string {\n    const player = gameState.players.find(p => p.id === playerId);\n    const handStr = `${holeCards[0].rank}${holeCards[0].suit} ${holeCards[1].rank}${holeCards[1].suit}`;\n    const position = this.getPlayerPosition(gameState, playerId);\n    const toCall = this.getAmountToCall(gameState, playerId);\n    const actionHistory = this.getActionHistory(gameState);\n    const opponents = this.getActiveOpponents(gameState, playerId);\n\n    return `=== TEXAS HOLDEM DECISION ===\nYOUR HAND: ${handStr}\nBOARD: ${this.getBoardString(gameState.communityCards)}\nPOSITION: ${position} (${player?.position + 1}/${gameState.players.length} players)\nCHIPS: ${player?.chips || 0} | POT: ${gameState.pot} | TO CALL: ${toCall}\nPHASE: ${gameState.phase}\n\nCOMPLETE GAME STATE:\n${JSON.stringify({\n  gameState: {\n    phase: gameState.phase,\n    pot: gameState.pot,\n    currentBet: gameState.currentBet,\n    bigBlind: gameState.bigBlind,\n    board: gameState.communityCards.map(c => `${c.rank}${c.suit}`),\n    myPosition: position,\n    myChips: player?.chips || 0,\n    myCards: [holeCards[0], holeCards[1]].map(c => `${c.rank}${c.suit}`),\n    toCall: toCall,\n    potOdds: toCall > 0 ? `${(gameState.pot / toCall).toFixed(1)}:1` : \"N/A\"\n  },\n  detailedBettingHistory: this.buildDetailedBettingSequence(gameState),\n  currentRoundSummary: this.buildCurrentRoundSummary(gameState),\n  opponents: opponents.map(opp => ({\n    name: opp.name,\n    position: this.getPlayerPosition(gameState, opp.id),\n    chips: opp.chips,\n    isActive: opp.isActive,\n    style: \"unknown\" // 可以后续添加\n  })),\n  gameFormat: {\n    blinds: `${gameState.smallBlind}/${gameState.bigBlind}`,\n    tableSize: gameState.players.length,\n    gameType: \"cash\"\n  }\n}, null, 2)}\n\nRESPOND ONLY: {\"action\":\"fold/check/call/raise/all-in\",\"amount\":number,\"confidence\":0.8}`;\n\n    // 调试：打印完整Prompt\n    console.log(`🔍 标准Prompt内容:\\n${result}`);\n    return result;\n  }\n\n  // 🔍 详细Prompt - 用于复杂决策\n  private generateDetailedPrompt(\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[],\n    timeLimit: number,\n    temperature: number\n  ): string {\n    const player = gameState.players.find(p => p.id === playerId);\n    const handStr = `${holeCards[0].rank}${holeCards[0].suit} ${holeCards[1].rank}${holeCards[1].suit}`;\n    const position = this.getPlayerPosition(gameState, playerId);\n    const toCall = this.getAmountToCall(gameState, playerId);\n    const actionHistory = this.getActionHistory(gameState);\n    const opponents = this.getActiveOpponents(gameState, playerId);\n\n    return `=== COMPLEX POKER DECISION ===\nYOUR HAND: ${handStr}\nBOARD: ${this.getBoardString(gameState.communityCards)}\nPOSITION: ${position} (${player?.position + 1}/${gameState.players.length} players)\nCHIPS: ${player?.chips || 0} | POT: ${gameState.pot} | TO CALL: ${toCall}\n\nCOMPLETE GAME DATA:\n${JSON.stringify({\n  gameState: {\n    phase: gameState.phase,\n    pot: gameState.pot,\n    currentBet: gameState.currentBet,\n    bigBlind: gameState.bigBlind,\n    board: gameState.communityCards.map(c => `${c.rank}${c.suit}`),\n    myPosition: position,\n    myChips: player?.chips || 0,\n    myCards: [holeCards[0], holeCards[1]].map(c => `${c.rank}${c.suit}`),\n    toCall: toCall,\n    potOdds: toCall > 0 ? `${(gameState.pot / toCall).toFixed(1)}:1` : \"N/A\",\n    stackToPotRatio: toCall > 0 ? ((player?.chips || 0) / gameState.pot).toFixed(1) : \"N/A\"\n  },\n  detailedBettingHistory: this.buildDetailedBettingSequence(gameState),\n  currentRoundSummary: this.buildCurrentRoundSummary(gameState),\n  opponents: opponents.map(opp => ({\n    name: opp.name,\n    position: this.getPlayerPosition(gameState, opp.id),\n    chips: opp.chips,\n    isActive: opp.isActive,\n    stackBB: Math.round((opp.chips || 0) / gameState.bigBlind)\n  })),\n  boardAnalysis: {\n    texture: this.analyzeBoardTexture(gameState.communityCards),\n    drawPossible: gameState.communityCards.length >= 3,\n    pairedBoard: this.isPairedBoard(gameState.communityCards)\n  },\n  gameFormat: {\n    blinds: `${gameState.smallBlind}/${gameState.bigBlind}`,\n    tableSize: gameState.players.length,\n    gameType: \"cash\",\n    effectiveStacks: Math.min(...opponents.map(opp => opp.chips || 0), player?.chips || 0)\n  }\n}, null, 2)}\n\nANALYZE: Hand strength, position, pot odds, opponent ranges, board texture\nRESPOND ONLY: {\"action\":\"fold/check/call/raise/all-in\",\"amount\":number,\"confidence\":0.8}`;\n\n    // 调试：打印完整Prompt\n    console.log(`🔍 详细Prompt内容:\\n${result}`);\n    return result;\n  }\n\n  // 🧠 综合Prompt - 用于极复杂决策\n  private generateComprehensivePrompt(\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[],\n    timeLimit: number,\n    temperature: number\n  ): string {\n    const player = gameState.players.find(p => p.id === playerId);\n    const handStr = `${holeCards[0].rank}${holeCards[0].suit} ${holeCards[1].rank}${holeCards[1].suit}`;\n    const position = this.getPlayerPosition(gameState, playerId);\n    const toCall = this.getAmountToCall(gameState, playerId);\n    const opponents = this.getActiveOpponents(gameState, playerId);\n\n    return `=== EXPERT POKER ANALYSIS ===\nYOUR HAND: ${handStr}\nBOARD: ${this.getBoardString(gameState.communityCards)}\nPOSITION: ${position} (${player?.position + 1}/${gameState.players.length} players)\nCHIPS: ${player?.chips || 0} | POT: ${gameState.pot} | TO CALL: ${toCall}\n\nCOMPLETE EXPERT GAME DATA:\n${JSON.stringify({\n  gameState: {\n    phase: gameState.phase,\n    pot: gameState.pot,\n    currentBet: gameState.currentBet,\n    bigBlind: gameState.bigBlind,\n    board: gameState.communityCards.map(c => `${c.rank}${c.suit}`),\n    myPosition: position,\n    myChips: player?.chips || 0,\n    myCards: [holeCards[0], holeCards[1]].map(c => `${c.rank}${c.suit}`),\n    toCall: toCall,\n    potOdds: toCall > 0 ? `${(gameState.pot / toCall).toFixed(1)}:1` : \"N/A\",\n    stackToPotRatio: toCall > 0 ? ((player?.chips || 0) / gameState.pot).toFixed(1) : \"N/A\"\n  },\n  completeActionHistory: this.buildDetailedBettingSequence(gameState),\n  currentRoundAnalysis: this.buildCurrentRoundSummary(gameState),\n  opponents: opponents.map(opp => ({\n    name: opp.name,\n    position: this.getPlayerPosition(gameState, opp.id),\n    chips: opp.chips,\n    stackBB: Math.round((opp.chips || 0) / gameState.bigBlind),\n    isActive: opp.isActive\n  })),\n  expertAnalysis: {\n    boardTexture: this.analyzeBoardTexture(gameState.communityCards),\n    drawPossible: gameState.communityCards.length >= 3,\n    pairedBoard: this.isPairedBoard(gameState.communityCards),\n    flushPossible: this.isFlushPossible(gameState.communityCards),\n    straightPossible: this.isStraightPossible(gameState.communityCards)\n  },\n  gameFormat: {\n    blinds: `${gameState.smallBlind}/${gameState.bigBlind}`,\n    tableSize: gameState.players.length,\n    gameType: \"cash\",\n    effectiveStacks: Math.min(...opponents.map(opp => opp.chips || 0), player?.chips || 0)\n  }\n}, null, 2)}\n\nEXPERT ANALYSIS: Hand strength, position, complete betting history, opponent ranges, board texture, pot odds, implied odds, meta-game considerations\nRESPOND ONLY: {\"action\":\"fold/check/call/raise/all-in\",\"amount\":number,\"confidence\":0.8}`;\n\n    // 调试：打印完整Prompt\n    console.log(`🔍 专家级Prompt内容:\\n${result}`);\n    return result;\n  }\n\n  // 辅助方法 (简化实现)\n  private getBoardString(communityCards: Card[]): string {\n    if (!communityCards || !communityCards.length) return \"无\";\n    return communityCards.map(c => `${c.rank}${c.suit}`).join(' ');\n  }\n\n  private getPlayerPosition(gameState: NewGameState, playerId: string): string {\n    const player = gameState.players.find(p => p.id === playerId);\n    if (!player) return \"unknown\";\n\n    const totalPlayers = gameState.players.length;\n    const dealerIndex = gameState.dealerIndex;\n    const relativePosition = (player.position - dealerIndex + totalPlayers) % totalPlayers;\n\n    // 标准位置映射\n    const positions = ['BTN', 'SB', 'BB', 'UTG', 'UTG+1', 'UTG+2', 'MP', 'MP+1', 'CO'];\n\n    if (totalPlayers <= 6) {\n      const shortPositions = ['BTN', 'SB', 'BB', 'UTG', 'MP', 'CO'];\n      return shortPositions[relativePosition] || 'UTG';\n    }\n\n    return positions[relativePosition] || 'UTG';\n  }\n\n  private getAmountToCall(gameState: NewGameState, playerId: string): number {\n    const player = gameState.players.find(p => p.id === playerId);\n    if (!player) return 0;\n\n    const toCall = Math.max(0, gameState.currentBet - (player.currentBet || 0));\n\n    // 调试信息\n    console.log(`💰 计算跟注金额: 玩家${player.name}, 当前最高下注${gameState.currentBet}, 玩家已下注${player.currentBet || 0}, 需要跟注${toCall}`);\n\n    return toCall;\n  }\n\n  private getActionHistory(gameState: NewGameState): any[] {\n    const history = gameState.actionHistory || [];\n    console.log(`🔍 AdaptivePromptManager获取行动历史:`, {\n      原始长度: history.length,\n      原始数据: history,\n      gameState类型: typeof gameState,\n      gameState键: Object.keys(gameState),\n      第一个行动示例: history[0] || null\n    });\n\n    // 🔥 修复：转换ActionRecord格式到ActionHistoryItem格式\n    const convertedHistory = history.map(action => ({\n      playerName: action.playerName,\n      action: action.action,\n      amount: action.amount,\n      phase: action.phase,\n      timestamp: action.timestamp\n    }));\n\n    console.log(`🔄 转换后的行动历史:`, {\n      转换后长度: convertedHistory.length,\n      转换后数据: convertedHistory,\n      第一个转换示例: convertedHistory[0] || null\n    });\n\n    return convertedHistory;\n  }\n\n  private getActiveOpponents(gameState: NewGameState, playerId: string): any[] {\n    return gameState.players.filter(p => p.id !== playerId && p.isActive);\n  }\n\n  private analyzeBoardTexture(communityCards: Card[]): string {\n    if (!communityCards || communityCards.length === 0) return \"preflop\";\n\n    const suits = communityCards.map(c => c.suit);\n    const ranks = communityCards.map(c => c.rank);\n\n    // 检查同花可能\n    const suitCounts = suits.reduce((acc, suit) => {\n      acc[suit] = (acc[suit] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    const maxSuitCount = Math.max(...Object.values(suitCounts));\n    const flushDraw = maxSuitCount >= 3;\n\n    // 检查顺子可能\n    const rankValues = ranks.map(rank => {\n      if (rank === 'A') return 14;\n      if (rank === 'K') return 13;\n      if (rank === 'Q') return 12;\n      if (rank === 'J') return 11;\n      if (rank === '10') return 10;\n      return parseInt(rank);\n    }).sort((a, b) => a - b);\n\n    let straightDraw = false;\n    for (let i = 0; i < rankValues.length - 1; i++) {\n      if (rankValues[i + 1] - rankValues[i] === 1) {\n        straightDraw = true;\n        break;\n      }\n    }\n\n    if (flushDraw && straightDraw) return \"draw_heavy\";\n    if (flushDraw) return \"flush_draw\";\n    if (straightDraw) return \"straight_draw\";\n\n    return \"dry\";\n  }\n\n  private buildDetailedBettingSequence(gameState: NewGameState): any {\n    // 🔍 详细调试：检查传入的gameState\n    console.log(`🔍 buildDetailedBettingSequence接收到的gameState:`, {\n      gameState类型: typeof gameState,\n      gameState键: Object.keys(gameState),\n      actionHistory字段: gameState.actionHistory,\n      actionHistory长度: gameState.actionHistory?.length || 0,\n      actionHistory类型: typeof gameState.actionHistory\n    });\n\n    const actionHistory = this.getActionHistory(gameState);\n\n    // 调试信息\n    console.log(`🔍 构建下注序列: 总行动数${actionHistory?.length || 0}`, actionHistory);\n\n    if (!actionHistory || actionHistory.length === 0) {\n      console.log(`⚠️ 行动历史为空`);\n      return {\n        preflop: [],\n        flop: [],\n        turn: [],\n        river: [],\n        summary: \"No actions yet - action history is empty\"\n      };\n    }\n\n    // 按阶段分组行动\n    const actionsByPhase = {\n      preflop: actionHistory.filter(a => a.phase === 'preflop'),\n      flop: actionHistory.filter(a => a.phase === 'flop'),\n      turn: actionHistory.filter(a => a.phase === 'turn'),\n      river: actionHistory.filter(a => a.phase === 'river')\n    };\n\n    // 调试每个阶段的行动数量\n    console.log(`📊 各阶段行动统计:`, {\n      preflop: actionsByPhase.preflop.length,\n      flop: actionsByPhase.flop.length,\n      turn: actionsByPhase.turn.length,\n      river: actionsByPhase.river.length\n    });\n\n    // 构建每个阶段的行动序列\n    const formatActions = (actions: any[]) =>\n      actions.map(a => `${a.playerName}: ${a.action}${a.amount ? `(${a.amount})` : ''}`);\n\n    const result = {\n      preflop: formatActions(actionsByPhase.preflop),\n      flop: formatActions(actionsByPhase.flop),\n      turn: formatActions(actionsByPhase.turn),\n      river: formatActions(actionsByPhase.river),\n      summary: `Total actions: ${actionHistory.length}, Current phase: ${gameState.phase}`\n    };\n\n    console.log(`✅ 构建的下注序列:`, result);\n    return result;\n  }\n\n  private buildCurrentRoundSummary(gameState: NewGameState): string {\n    const allActions = this.getActionHistory(gameState);\n    const currentPhaseActions = allActions.filter(a => a.phase === gameState.phase);\n\n    console.log(`🔍 当前轮次总结: 阶段${gameState.phase}, 总行动${allActions.length}, 当前阶段行动${currentPhaseActions.length}`);\n    console.log(`📋 当前阶段行动详情:`, currentPhaseActions);\n\n    if (currentPhaseActions.length === 0) {\n      return `${gameState.phase} phase started, no actions yet`;\n    }\n\n    const actionSummary = currentPhaseActions\n      .map(a => `${a.playerName} ${a.action}${a.amount ? ` ${a.amount}` : ''}`)\n      .join(' → ');\n\n    const result = `${gameState.phase}: ${actionSummary}`;\n    console.log(`✅ 当前轮次总结结果: ${result}`);\n    return result;\n  }\n\n  private isPairedBoard(communityCards: Card[]): boolean {\n    if (!communityCards || communityCards.length < 2) return false;\n\n    const ranks = communityCards.map(c => c.rank);\n    const rankCounts = ranks.reduce((acc, rank) => {\n      acc[rank] = (acc[rank] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    return Object.values(rankCounts).some(count => count >= 2);\n  }\n\n  private isFlushPossible(communityCards: Card[]): boolean {\n    if (!communityCards || communityCards.length < 3) return false;\n\n    const suits = communityCards.map(c => c.suit);\n    const suitCounts = suits.reduce((acc, suit) => {\n      acc[suit] = (acc[suit] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    return Math.max(...Object.values(suitCounts)) >= 3;\n  }\n\n  private isStraightPossible(communityCards: Card[]): boolean {\n    if (!communityCards || communityCards.length < 3) return false;\n\n    const ranks = communityCards.map(c => c.rank);\n    const rankValues = ranks.map(rank => {\n      if (rank === 'A') return 14;\n      if (rank === 'K') return 13;\n      if (rank === 'Q') return 12;\n      if (rank === 'J') return 11;\n      if (rank === '10') return 10;\n      return parseInt(rank);\n    }).sort((a, b) => a - b);\n\n    // 检查是否有连续的牌\n    for (let i = 0; i < rankValues.length - 2; i++) {\n      if (rankValues[i + 1] - rankValues[i] === 1 && rankValues[i + 2] - rankValues[i + 1] === 1) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private getActiveOpponents(gameState: NewGameState, playerId: string): any[] {\n    return gameState.players.filter(p => p.isActive && p.id !== playerId);\n  }\n\n\n\n  private calculatePotOdds(gameState: NewGameState, playerId: string): string {\n    return \"2:1\"; // 简化实现\n  }\n\n  private calculateSPR(gameState: NewGameState, playerId: string): number {\n    return 5.0; // 简化实现\n  }\n\n\n\n  private getStackSizes(gameState: NewGameState): string {\n    return \"深筹码\"; // 简化实现\n  }\n\n\n\n  private getOpponentProfiles(gameState: NewGameState, playerId: string): Array<{name: string; style: string; vpip: number; pfr: number}> {\n    return []; // 简化实现\n  }\n\n  private analyzeGameFlow(gameState: NewGameState): {preflop: string; postflop: string; aggression: string} {\n    return {preflop: \"标准\", postflop: \"被动\", aggression: \"中等\"}; // 简化实现\n  }\n\n  private getPositionDetails(gameState: NewGameState, playerId: string): string {\n    return \"CO位\"; // 简化实现\n  }\n\n  private calculateImpliedOdds(gameState: NewGameState, playerId: string): string {\n    return \"良好\"; // 简化实现\n  }\n\n  private calculateReverseImpliedOdds(gameState: NewGameState, playerId: string): string {\n    return \"中等\"; // 简化实现\n  }\n}\n","import { AIDecision } from './ai-player';\n\n// 🔧 API配置\nexport interface APIConfig {\n  apiKey: string;\n  baseUrl: string;\n  model: string;\n  temperature: number;\n  maxTokens: number;\n  timeout: number;\n}\n\n// 📊 API连接状态\nexport interface APIConnection {\n  id: string;\n  config: APIConfig;\n  isActive: boolean;\n  requestCount: number;\n  errorCount: number;\n  averageResponseTime: number;\n  lastUsed: number;\n}\n\n// 🚀 AI API连接池\nexport class AIAPIPool {\n  private connections: APIConnection[] = [];\n  private currentConnectionIndex: number = 0;\n  private requestQueue: PendingRequest[] = [];\n  private isProcessingQueue: boolean = false;\n\n  constructor(apiConfig: APIConfig, poolSize: number = 3) {\n    this.initializeConnections(apiConfig, poolSize);\n    this.startQueueProcessor();\n    \n    console.log(`🚀 AI API连接池初始化完成 (${poolSize}个连接)`);\n  }\n\n  // 🏗️ 初始化连接池\n  private initializeConnections(baseConfig: APIConfig, poolSize: number): void {\n    for (let i = 0; i < poolSize; i++) {\n      const connection: APIConnection = {\n        id: `conn_${i}`,\n        config: { ...baseConfig },\n        isActive: true,\n        requestCount: 0,\n        errorCount: 0,\n        averageResponseTime: 0,\n        lastUsed: 0\n      };\n      \n      this.connections.push(connection);\n    }\n  }\n\n  // 🎯 发起决策请求\n  async makeDecisionRequest(prompt: string, timeLimit: number): Promise<AIDecision> {\n    return this.makeDecisionRequestWithConfig(prompt, timeLimit, this.connections[0]?.config.temperature || 0.1);\n  }\n\n  // 🎯 发起带配置的决策请求\n  async makeDecisionRequestWithConfig(prompt: string, timeLimit: number, temperature: number): Promise<AIDecision> {\n    const startTime = Date.now();\n\n    try {\n      // 选择最佳连接\n      const connection = this.selectBestConnection();\n\n      // 发起请求（使用动态温度）\n      const response = await this.makeAPIRequestWithConfig(connection, prompt, timeLimit, temperature);\n\n      // 解析响应\n      const decision = this.parseAIResponse(response);\n\n      // 更新连接统计\n      this.updateConnectionStats(connection, Date.now() - startTime, true);\n\n      return decision;\n\n    } catch (error) {\n      console.error('❌ AI API请求失败:', error);\n\n      // 尝试备用连接\n      return await this.tryBackupRequestWithConfig(prompt, timeLimit, temperature, startTime);\n    }\n  }\n\n  // 🔄 并行请求（修复版本 - 等待第一个成功的请求）\n  async makeParallelRequest(prompt: string, timeLimit: number): Promise<AIDecision> {\n    const activeConnections = this.connections.filter(c => c.isActive);\n\n    if (activeConnections.length === 0) {\n      throw new Error('没有可用的API连接');\n    }\n\n    // 🚀 优化：对于德州扑克，直接使用单一请求更高效\n    console.log('🎯 使用单一请求替代并行请求（更稳定）');\n    return this.makeDecisionRequest(prompt, timeLimit);\n\n    // 注释掉原来的并行逻辑，保留以备将来需要\n    /*\n    // 同时发起多个请求\n    const promises = activeConnections.slice(0, 2).map(async (connection) => {\n      try {\n        const response = await this.makeAPIRequest(connection, prompt, timeLimit);\n        return this.parseAIResponse(response);\n      } catch (error) {\n        throw error;\n      }\n    });\n\n    // 使用Promise.allSettled等待所有请求完成，返回第一个成功的\n    const results = await Promise.allSettled(promises);\n    const successfulResult = results.find(result => result.status === 'fulfilled');\n\n    if (successfulResult && successfulResult.status === 'fulfilled') {\n      console.log('⚡ 并行请求成功');\n      return successfulResult.value;\n    } else {\n      console.error('❌ 所有并行请求都失败了');\n      throw new Error('所有并行请求都失败了');\n    }\n    */\n  }\n\n  // 🎯 选择最佳连接\n  private selectBestConnection(): APIConnection {\n    const activeConnections = this.connections.filter(c => c.isActive);\n    \n    if (activeConnections.length === 0) {\n      throw new Error('没有可用的API连接');\n    }\n\n    // 基于性能选择连接\n    const bestConnection = activeConnections.reduce((best, current) => {\n      const bestScore = this.calculateConnectionScore(best);\n      const currentScore = this.calculateConnectionScore(current);\n      return currentScore > bestScore ? current : best;\n    });\n\n    return bestConnection;\n  }\n\n  // 📊 计算连接评分\n  private calculateConnectionScore(connection: APIConnection): number {\n    const successRate = connection.requestCount > 0 ? \n      (connection.requestCount - connection.errorCount) / connection.requestCount : 1;\n    \n    const responseTimeScore = connection.averageResponseTime > 0 ? \n      Math.max(0, 1 - connection.averageResponseTime / 10000) : 1; // 10秒为基准\n    \n    const recentUsageScore = Date.now() - connection.lastUsed > 5000 ? 1 : 0.5; // 5秒冷却\n    \n    return successRate * 0.5 + responseTimeScore * 0.3 + recentUsageScore * 0.2;\n  }\n\n  // 🌐 发起API请求\n  private async makeAPIRequest(connection: APIConnection, prompt: string, timeLimit: number): Promise<string> {\n    return this.makeAPIRequestWithConfig(connection, prompt, timeLimit, connection.config.temperature);\n  }\n\n  // 🌐 发起带配置的API请求\n  private async makeAPIRequestWithConfig(connection: APIConnection, prompt: string, timeLimit: number, temperature: number): Promise<string> {\n    // 移除超时控制\n    const controller = new AbortController();\n    let timeoutId: NodeJS.Timeout | null = null;\n\n    // 只有在timeLimit > 0时才设置超时\n    if (timeLimit > 0) {\n      timeoutId = setTimeout(() => controller.abort(), timeLimit);\n    }\n\n    try {\n      const response = await fetch(`${connection.config.baseUrl}/v1/chat/completions`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Authorization': `Bearer ${connection.config.apiKey}`\n        },\n        body: JSON.stringify({\n          model: connection.config.model,\n          messages: [\n            {\n              role: 'system',\n              content: '你是世界顶级的德州扑克AI，专注于快速、准确的决策。'\n            },\n            {\n              role: 'user',\n              content: prompt\n            }\n          ],\n          temperature: temperature, // 使用动态温度\n          max_tokens: connection.config.maxTokens,\n          stream: false\n        }),\n        signal: controller.signal\n      });\n\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n\n      if (!response.ok) {\n        throw new Error(`API请求失败: ${response.status} ${response.statusText}`);\n      }\n\n      const data = await response.json();\n\n      if (!data.choices || !data.choices[0] || !data.choices[0].message) {\n        throw new Error('API响应格式错误');\n      }\n\n      return data.choices[0].message.content;\n\n    } catch (error) {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n\n      if (error.name === 'AbortError') {\n        throw new Error(`API请求被中止`);\n      }\n\n      throw error;\n    }\n  }\n\n  // 🔍 解析AI响应\n  private parseAIResponse(responseText: string): AIDecision {\n    try {\n      // 尝试提取JSON\n      const jsonMatch = responseText.match(/\\{[\\s\\S]*\\}/);\n      if (!jsonMatch) {\n        throw new Error('响应中未找到JSON格式');\n      }\n\n      const jsonStr = jsonMatch[0];\n      const parsed = JSON.parse(jsonStr);\n\n      // 验证必需字段\n      if (!parsed.action || !['fold', 'check', 'call', 'bet', 'raise', 'all-in'].includes(parsed.action)) {\n        throw new Error('无效的行动类型');\n      }\n\n      // 构建标准决策对象\n      const decision: AIDecision = {\n        action: parsed.action === 'bet' ? 'raise' : parsed.action, // 统一bet为raise\n        amount: parsed.amount || 0,\n        confidence: parsed.confidence || 0.5,\n        reasoning: parsed.reasoning || '无推理信息',\n        decisionTime: 0, // 会在外层设置\n        metadata: {\n          handStrength: parsed.hand_strength || parsed.handStrength || 0.5,\n          positionFactor: parsed.position_factor || parsed.positionFactor || 'unknown',\n          opponentAdjustment: parsed.opponent_adjustment || parsed.opponentAdjustment || 'standard',\n          playType: parsed.play_type || parsed.playType || 'unknown'\n        }\n      };\n\n      console.log('✅ AI响应解析成功:', decision.action);\n      return decision;\n\n    } catch (error) {\n      console.error('❌ AI响应解析失败:', error);\n      console.log('原始响应:', responseText);\n      \n      // 返回安全的默认决策\n      return {\n        action: 'fold',\n        amount: 0,\n        confidence: 0.3,\n        reasoning: '响应解析失败，安全弃牌',\n        decisionTime: 0,\n        metadata: {\n          handStrength: 0,\n          positionFactor: 'unknown',\n          opponentAdjustment: 'error',\n          playType: 'emergency_fold'\n        }\n      };\n    }\n  }\n\n  // 🔄 尝试备用请求\n  private async tryBackupRequest(prompt: string, timeLimit: number, startTime: number): Promise<AIDecision> {\n    return this.tryBackupRequestWithConfig(prompt, timeLimit, this.connections[0]?.config.temperature || 0.1, startTime);\n  }\n\n  // 🔄 尝试带配置的备用请求\n  private async tryBackupRequestWithConfig(prompt: string, timeLimit: number, temperature: number, startTime: number): Promise<AIDecision> {\n    const remainingTime = Math.max(1000, timeLimit - (Date.now() - startTime));\n\n    // 尝试其他连接\n    const backupConnections = this.connections.filter(c => c.isActive);\n\n    for (const connection of backupConnections) {\n      try {\n        console.log(`🔄 尝试备用连接: ${connection.id} (温度: ${temperature})`);\n\n        const response = await this.makeAPIRequestWithConfig(connection, prompt, remainingTime, temperature);\n        const decision = this.parseAIResponse(response);\n\n        this.updateConnectionStats(connection, Date.now() - startTime, true);\n        return decision;\n\n      } catch (error) {\n        console.log(`❌ 备用连接失败: ${connection.id}`);\n        this.updateConnectionStats(connection, Date.now() - startTime, false);\n      }\n    }\n\n    // 所有连接都失败，返回紧急决策\n    console.error('❌ 所有API连接都失败了');\n    return this.getEmergencyDecision();\n  }\n\n  // 🚨 紧急决策\n  private getEmergencyDecision(): AIDecision {\n    return {\n      action: 'fold',\n      amount: 0,\n      confidence: 0.1,\n      reasoning: 'API连接失败，紧急弃牌',\n      decisionTime: 0,\n      metadata: {\n        handStrength: 0,\n        positionFactor: 'unknown',\n        opponentAdjustment: 'emergency',\n        playType: 'emergency_fold'\n      }\n    };\n  }\n\n  // 📊 更新连接统计\n  private updateConnectionStats(connection: APIConnection, responseTime: number, success: boolean): void {\n    connection.requestCount++;\n    connection.lastUsed = Date.now();\n\n    if (success) {\n      // 更新平均响应时间\n      connection.averageResponseTime = \n        (connection.averageResponseTime * (connection.requestCount - 1) + responseTime) / connection.requestCount;\n    } else {\n      connection.errorCount++;\n      \n      // 如果错误率过高，暂时禁用连接\n      const errorRate = connection.errorCount / connection.requestCount;\n      if (errorRate > 0.5 && connection.requestCount > 5) {\n        connection.isActive = false;\n        console.warn(`⚠️ 连接 ${connection.id} 错误率过高，暂时禁用`);\n        \n        // 5分钟后重新启用\n        setTimeout(() => {\n          connection.isActive = true;\n          connection.errorCount = 0;\n          console.log(`🔄 连接 ${connection.id} 重新启用`);\n        }, 300000);\n      }\n    }\n  }\n\n  // 🔄 队列处理器\n  private startQueueProcessor(): void {\n    setInterval(() => {\n      if (!this.isProcessingQueue && this.requestQueue.length > 0) {\n        this.processRequestQueue();\n      }\n    }, 100);\n  }\n\n  private async processRequestQueue(): Promise<void> {\n    if (this.requestQueue.length === 0) return;\n\n    this.isProcessingQueue = true;\n    \n    const request = this.requestQueue.shift()!;\n    \n    try {\n      const decision = await this.makeDecisionRequest(request.prompt, request.timeLimit);\n      request.resolve(decision);\n    } catch (error) {\n      request.reject(error);\n    }\n    \n    this.isProcessingQueue = false;\n  }\n\n  // 📊 获取连接池状态\n  getPoolStatus(): PoolStatus {\n    const activeConnections = this.connections.filter(c => c.isActive).length;\n    const totalRequests = this.connections.reduce((sum, c) => sum + c.requestCount, 0);\n    const totalErrors = this.connections.reduce((sum, c) => sum + c.errorCount, 0);\n    const averageResponseTime = this.connections.reduce((sum, c) => sum + c.averageResponseTime, 0) / this.connections.length;\n\n    return {\n      totalConnections: this.connections.length,\n      activeConnections,\n      totalRequests,\n      totalErrors,\n      successRate: totalRequests > 0 ? (totalRequests - totalErrors) / totalRequests : 1,\n      averageResponseTime,\n      queueLength: this.requestQueue.length\n    };\n  }\n\n  // 🧹 清理资源\n  cleanup(): void {\n    this.connections.forEach(connection => {\n      connection.isActive = false;\n    });\n    \n    this.requestQueue = [];\n    console.log('🧹 AI API连接池已清理');\n  }\n}\n\n// 🔧 辅助接口\ninterface PendingRequest {\n  prompt: string;\n  timeLimit: number;\n  resolve: (decision: AIDecision) => void;\n  reject: (error: Error) => void;\n}\n\nexport interface PoolStatus {\n  totalConnections: number;\n  activeConnections: number;\n  totalRequests: number;\n  totalErrors: number;\n  successRate: number;\n  averageResponseTime: number;\n  queueLength: number;\n}\n","import { NewGameState } from '../core/game-engine';\nimport { Card } from '../types/poker';\n\n// 📊 复杂度评估结果\nexport interface ComplexityAssessment {\n    totalScore: number;        // 总复杂度分数 (0-100)\n    category: 'simple' | 'medium' | 'complex' | 'extreme';\n    factors: {\n      handStrengthAmbiguity: number;    // 牌力模糊度 (0-25)\n      opponentRangeWidth: number;       // 对手范围宽度 (0-25) \n      actionSequenceComplexity: number; // 行动序列复杂度 (0-25)\n      stackAndPotDynamics: number;      // 筹码和底池动态 (0-25)\n    };\n    recommendedTimeout: number;         // 推荐超时时间(ms)\n    recommendedTemperature: number;     // 推荐AI温度\n    promptType: 'minimal' | 'standard' | 'detailed' | 'comprehensive';\n  }\n\n// 🎯 局势复杂度分析器\nexport class SituationComplexityAnalyzer {\n\n  // 🎯 主要分析入口\n  analyzeSituation(\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[]\n  ): ComplexityAssessment {\n\n    // 🚀 调试：检查gameState.phase\n    console.log('🔍 SituationComplexityAnalyzer收到的gameState:', {\n      phase: gameState.phase,\n      phaseType: typeof gameState.phase,\n      gameStateKeys: Object.keys(gameState),\n      hasPhase: 'phase' in gameState,\n      gameStateStructure: {\n        gameId: gameState.gameId,\n        phase: gameState.phase,\n        players: gameState.players?.length,\n        pot: gameState.pot\n      }\n    });\n\n    // 简化实现：基于游戏阶段的基础复杂度评估\n    let baseScore = 0;\n\n    // 根据游戏阶段设置基础分数\n    switch (gameState.phase) {\n      case 'preflop':\n        baseScore = 20; // 翻前相对简单\n        break;\n      case 'flop':\n        baseScore = 35; // 翻牌中等复杂\n        break;\n      case 'turn':\n        baseScore = 50; // 转牌较复杂\n        break;\n      case 'river':\n        baseScore = 65; // 河牌最复杂\n        break;\n      default:\n        baseScore = 30;\n    }\n\n    // 根据底池大小调整\n    const pot = gameState.pot || 0;\n    const bigBlind = gameState.bigBlind || 100;\n    const potBBs = pot / bigBlind;\n\n    if (potBBs > 20) baseScore += 15; // 大底池增加复杂度\n    else if (potBBs > 10) baseScore += 8;\n    else if (potBBs > 5) baseScore += 3;\n\n    // 根据对手数量调整\n    const activeOpponents = gameState.players.filter(p => p.isActive && p.id !== playerId).length;\n    if (activeOpponents >= 3) baseScore += 10; // 多人底池\n    else if (activeOpponents >= 2) baseScore += 5;\n\n    const totalScore = Math.min(baseScore, 100);\n\n    const factors = {\n      handStrengthAmbiguity: Math.floor(totalScore * 0.3),\n      opponentRangeWidth: Math.floor(totalScore * 0.25),\n      actionSequenceComplexity: Math.floor(totalScore * 0.25),\n      stackAndPotDynamics: Math.floor(totalScore * 0.2)\n    };\n\n    return {\n      totalScore,\n      category: this.categorizeComplexity(totalScore),\n      factors,\n      recommendedTimeout: this.getRecommendedTimeout(totalScore),\n      recommendedTemperature: this.getRecommendedTemperature(totalScore),\n      promptType: this.getPromptType(totalScore)\n    };\n  }\n\n  // 🏷️ 复杂度分类\n  private categorizeComplexity(score: number): 'simple' | 'medium' | 'complex' | 'extreme' {\n    if (score <= 25) return 'simple';\n    if (score <= 50) return 'medium';\n    if (score <= 75) return 'complex';\n    return 'extreme';\n  }\n\n  // ⏱️ 推荐超时时间 (临时放宽限制确保稳定性)\n  private getRecommendedTimeout(score: number): number {\n    if (score <= 25) return 15000;  // 15秒 - 简单局势\n    if (score <= 50) return 25000;  // 25秒 - 中等复杂度\n    if (score <= 75) return 35000;  // 35秒 - 复杂局势\n    return 45000; // 45秒 - 极复杂局势\n  }\n\n  // 🌡️ 推荐AI温度\n  private getRecommendedTemperature(score: number): number {\n    if (score <= 25) return 0.1;   // 简单局势，低温度\n    if (score <= 50) return 0.3;   // 中等复杂，中等温度\n    if (score <= 75) return 0.5;   // 复杂局势，较高温度\n    return 0.7; // 极复杂，高温度保持创造性\n  }\n\n  // 📝 推荐Prompt类型\n  private getPromptType(score: number): 'minimal' | 'standard' | 'detailed' | 'comprehensive' {\n    if (score <= 25) return 'minimal';\n    if (score <= 50) return 'standard';\n    if (score <= 75) return 'detailed';\n    return 'comprehensive';\n  }\n}\n","import { NewGameState } from '../core/game-engine';\nimport { Card } from '../types/poker';\nimport { AdaptivePromptManager } from './adaptive-prompt-manager.ts';\nimport { AIAPIPool } from './ai-api-pool.ts';\nimport { AIDecision, OpponentProfile } from './ai-player.ts';\nimport { SituationComplexityAnalyzer } from './situation-complexity-analyzer.ts';\n\n// 🎯 游戏数据结构\nexport interface GameData {\n  // 基础信息\n  position: string;\n  positionIndex: number;\n  holeCards: string;\n  myChips: number;\n  pot: number;\n  currentBet: number;\n  toCall: number;\n\n  // 牌面信息\n  board?: string;\n  boardTexture?: string;\n  drawHeavy?: boolean;\n\n  // 对手信息\n  activePlayers: number;\n  totalPlayers: number;\n  actionSequence: string;\n  opponentProfiles: OpponentProfileSummary[];\n  opponentRanges?: string;\n\n  // 赔率信息\n  potOdds: string;\n\n  // 行动历史\n  currentRoundActions?: string;\n  recentOpponentBehavior?: string;\n\n  // 时间信息\n  timeLimit: number;\n  phase: string;\n}\n\nexport interface OpponentProfileSummary {\n  name: string;\n  position: string;\n  vpip: number;\n  pfr: number;\n  aggression: number;\n  tendency: string;\n}\n\n// 🚀 决策层级\nexport enum DecisionLayer {\n  FAST_FILTER = 1,    // 快速过滤 (50ms)\n  STRATEGY_ANALYSIS = 2, // 策略分析 (1-3s)\n  FINE_TUNING = 3     // 精细调整 (200ms)\n}\n\n// 📊 决策缓存\nexport interface CachedDecision {\n  situationKey: string;\n  decision: AIDecision;\n  timestamp: number;\n  hitCount: number;\n  confidence: number;\n}\n\n// ⚡ 快速决策引擎\nexport class FastDecisionEngine {\n  private decisionCache: Map<string, CachedDecision> = new Map();\n  private apiPool: AIAPIPool;\n  private promptManager: PromptManager;\n  private performanceTracker: PerformanceTracker;\n  private complexityAnalyzer: SituationComplexityAnalyzer;\n  private adaptivePromptManager: AdaptivePromptManager;\n\n  constructor(apiConfig: any) {\n    const poolConfig = {\n      apiKey: apiConfig.apiKey,\n      baseUrl: apiConfig.baseUrl,\n      model: apiConfig.model,\n      temperature: 0.1,\n      maxTokens: 150,\n      timeout: 0 // 移除超时限制\n    };\n\n    this.apiPool = new AIAPIPool(poolConfig, 3); // 3个并行连接\n    this.promptManager = new PromptManager();\n    this.performanceTracker = new PerformanceTracker();\n    this.complexityAnalyzer = new SituationComplexityAnalyzer();\n    this.adaptivePromptManager = new AdaptivePromptManager();\n\n    console.log('⚡ 快速决策引擎初始化完成 (移除超时限制)');\n  }\n\n  // 🎯 主决策入口\n  async makeDecision(\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[],\n    opponentProfiles: Map<string, OpponentProfile>,\n    timeLimit: number = 0 // 移除时间限制\n  ): Promise<AIDecision> {\n    const startTime = Date.now();\n\n    try {\n      // 🚀 翻前优先使用GTO查表 (0ms决策)\n      if (gameState.phase === 'preflop') {\n        console.log('⚡ 翻前阶段，使用GTO查表决策');\n\n        try {\n          const gtoDecision = await this.getGTOPreflopDecision(gameState, playerId, holeCards);\n          if (gtoDecision) {\n            const totalTime = Date.now() - startTime;\n            console.log(`⚡ GTO翻前决策完成: ${gtoDecision.action} (${totalTime}ms)`);\n            return gtoDecision;\n          }\n        } catch (gtoError) {\n          console.warn('⚠️ GTO决策失败，回退到AI决策:', gtoError);\n        }\n      }\n\n      // 🔥 直接使用AI决策系统 (更可靠)\n      console.log('🧠 使用AI决策系统 (GTO服务已禁用)');\n\n      // 构建游戏数据\n      const gameData = this.buildGameData(gameState, playerId, holeCards, opponentProfiles, timeLimit);\n\n      // 三层决策架构\n      const decision = await this.executeLayeredDecision(gameData, gameState, playerId, holeCards);\n\n      // 记录性能\n      const totalTime = Date.now() - startTime;\n      this.performanceTracker.recordDecision(playerId, totalTime, decision.confidence);\n\n      console.log(`⚡ 决策完成: ${decision.action} (${totalTime}ms)`);\n\n      return decision;\n\n    } catch (error) {\n      console.error('❌ 决策引擎错误:', error);\n\n      // 返回安全的默认决策\n      return this.getEmergencyDecision(gameState, holeCards);\n    }\n  }\n\n  // 🏗️ 构建游戏数据\n  private buildGameData(\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[],\n    opponentProfiles: Map<string, OpponentProfile>,\n    timeLimit: number\n  ): GameData {\n    const player = gameState.players.find(p => p.id === playerId);\n    if (!player) throw new Error('玩家不存在');\n\n    const position = this.getPlayerPosition(gameState, playerId);\n    const positionIndex = gameState.players.findIndex(p => p.id === playerId);\n\n    // 构建对手档案摘要\n    const opponentSummaries: OpponentProfileSummary[] = [];\n    gameState.players.forEach(p => {\n      if (p.id !== playerId) {\n        const profile = opponentProfiles.get(p.id);\n        if (profile) {\n          opponentSummaries.push({\n            name: p.name,\n            position: this.getPlayerPosition(gameState, p.id),\n            vpip: profile.vpip,\n            pfr: profile.pfr,\n            aggression: profile.aggression,\n            tendency: profile.tendency\n          });\n        }\n      }\n    });\n\n    // 构建行动序列\n    const actionSequence = this.buildActionSequence(gameState);\n\n    // 计算底池赔率\n    const toCall = Math.max(0, gameState.currentBet - (player.currentBet || 0));\n    const potOdds = toCall > 0 ? `${(gameState.pot / toCall).toFixed(1)}:1` : 'N/A';\n\n    return {\n      position,\n      positionIndex,\n      holeCards: this.formatCards(holeCards),\n      myChips: player.chips,\n      pot: gameState.pot,\n      currentBet: gameState.currentBet,\n      toCall,\n      activePlayers: gameState.players.filter(p => p.isActive).length,\n      totalPlayers: gameState.players.length,\n      actionSequence,\n      opponentProfiles: opponentSummaries,\n      potOdds,\n      timeLimit,\n      phase: gameState.phase,\n\n      // 翻牌后信息\n      ...(gameState.phase !== 'preflop' && {\n        board: this.formatCards(gameState.communityCards),\n        boardTexture: this.analyzeBoardTexture(gameState.communityCards),\n        drawHeavy: this.isDrawHeavyBoard(gameState.communityCards),\n        currentRoundActions: this.buildCurrentRoundActions(gameState),\n        recentOpponentBehavior: this.buildOpponentBehaviorSummary(opponentProfiles)\n      })\n    };\n  }\n\n  // 🎯 执行分层决策\n  private async executeLayeredDecision(\n    gameData: GameData,\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[]\n  ): Promise<AIDecision> {\n    console.log('🚀 强制使用AI API决策 - 跳过缓存和明显决策');\n\n    // 直接进行策略分析 (强制使用API)\n    const strategicDecision = await this.performStrategicAnalysis(gameData, gameState, playerId, holeCards);\n\n    // Layer 3: 精细调整\n    const finalDecision = this.applyFineTuning(strategicDecision, gameData);\n\n    return finalDecision;\n  }\n\n  // ⚡ 尝试快速决策\n  private async tryQuickDecision(gameData: GameData): Promise<AIDecision | null> {\n    const startTime = Date.now();\n\n    // 检查缓存\n    const cachedDecision = this.checkDecisionCache(gameData);\n    if (cachedDecision) {\n      console.log('🎯 缓存命中');\n      return cachedDecision.decision;\n    }\n\n    // 明显的决策情况\n    const obviousDecision = this.checkObviousDecisions(gameData);\n    if (obviousDecision) {\n      console.log('🎯 明显决策');\n      return obviousDecision;\n    }\n\n    const elapsed = Date.now() - startTime;\n    if (elapsed > 50) {\n      console.log(`⚠️ 快速决策超时: ${elapsed}ms`);\n    }\n\n    return null;\n  }\n\n  // 🧠 执行策略分析\n  private async performStrategicAnalysis(\n    gameData: GameData,\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[]\n  ): Promise<AIDecision> {\n    const startTime = Date.now();\n\n    try {\n      // 🎯 分析局势复杂度\n      const complexityAssessment = this.complexityAnalyzer.analyzeSituation(\n        gameState,\n        playerId,\n        holeCards\n      );\n\n      console.log(`🎯 局势复杂度: ${complexityAssessment.category} (${complexityAssessment.totalScore}/100)`);\n      console.log(`📊 推荐: 超时${complexityAssessment.recommendedTimeout}ms, 温度${complexityAssessment.recommendedTemperature}, Prompt${complexityAssessment.promptType}`);\n\n      // 🚀 移除超时限制，使用推荐温度\n      const dynamicTimeLimit = 0; // 完全移除超时限制\n\n      // 📝 生成自适应Prompt\n      const adaptivePrompt = this.adaptivePromptManager.generatePrompt(\n        gameState,\n        playerId,\n        holeCards,\n        complexityAssessment.promptType,\n        dynamicTimeLimit,\n        complexityAssessment.recommendedTemperature\n      );\n\n      console.log(`🧠 发起智能AI决策请求 (无时限, 温度: ${complexityAssessment.recommendedTemperature})`);\n\n      // 🚀 使用动态配置的API请求\n      const decision = await this.apiPool.makeDecisionRequestWithConfig(\n        adaptivePrompt,\n        dynamicTimeLimit,\n        complexityAssessment.recommendedTemperature\n      );\n      console.log('⚡ 智能AI决策请求成功');\n\n      // 设置决策时间和复杂度信息\n      decision.decisionTime = Date.now() - startTime;\n      decision.metadata = {\n        ...decision.metadata,\n        complexityScore: complexityAssessment.totalScore,\n        complexityCategory: complexityAssessment.category,\n        promptType: complexityAssessment.promptType\n      };\n\n      // 缓存决策\n      this.cacheDecision(gameData, decision);\n\n      const elapsed = Date.now() - startTime;\n      console.log(`🧠 智能策略分析完成: ${elapsed}ms, 决策: ${decision.action}, 复杂度: ${complexityAssessment.category}`);\n\n      return decision;\n\n    } catch (error) {\n      console.error('❌ 策略分析失败:', error);\n\n      // 回退到基础决策\n      const fallbackDecision = this.getBasicDecision(gameData);\n      fallbackDecision.decisionTime = Date.now() - startTime;\n      fallbackDecision.reasoning += ' (AI失败回退)';\n\n      return fallbackDecision;\n    }\n  }\n\n  // 🎨 应用精细调整\n  private applyFineTuning(decision: AIDecision, gameData: GameData): AIDecision {\n    const startTime = Date.now();\n\n    // 随机化处理（避免被读牌）\n    if (decision.action === 'raise' && Math.random() < 0.1) {\n      // 10%概率调整下注尺寸\n      decision.amount = Math.floor(decision.amount * (0.8 + Math.random() * 0.4));\n    }\n\n    // 位置调整\n    if (gameData.position === 'BTN' && decision.action === 'call') {\n      // 按钮位置更激进\n      if (Math.random() < 0.2) {\n        decision.action = 'raise';\n        decision.amount = gameData.currentBet * 2.5;\n        decision.reasoning += ' (按钮位置加注)';\n      }\n    }\n\n    // 筹码深度调整\n    const stackBB = gameData.myChips / 100; // 转换为大盲倍数\n    if (stackBB < 20 && decision.action === 'call') {\n      // 短筹码更激进\n      decision.action = 'raise';\n      decision.amount = gameData.myChips; // 全押\n      decision.reasoning += ' (短筹码全押)';\n    }\n\n    const elapsed = Date.now() - startTime;\n    console.log(`🎨 精细调整完成: ${elapsed}ms`);\n\n    return decision;\n  }\n\n  // 🎯 检查明显决策\n  private checkObviousDecisions(gameData: GameData): AIDecision | null {\n    // 超强牌\n    if (this.isNutsHand(gameData.holeCards, gameData.board)) {\n      return {\n        action: 'raise',\n        amount: gameData.pot * 0.8,\n        confidence: 0.95,\n        reasoning: '超强牌价值下注',\n        decisionTime: 50,\n        metadata: {\n          handStrength: 0.95,\n          positionFactor: gameData.position,\n          opponentAdjustment: 'value',\n          playType: 'value'\n        }\n      };\n    }\n\n    // 垃圾牌面对大注\n    if (this.isTrashHand(gameData.holeCards) && gameData.toCall > gameData.pot * 0.5) {\n      return {\n        action: 'fold',\n        amount: 0,\n        confidence: 0.9,\n        reasoning: '垃圾牌面对大注',\n        decisionTime: 50,\n        metadata: {\n          handStrength: 0.1,\n          positionFactor: gameData.position,\n          opponentAdjustment: 'fold',\n          playType: 'fold'\n        }\n      };\n    }\n\n    // 免费看牌\n    if (gameData.toCall === 0) {\n      return {\n        action: 'check',\n        amount: 0,\n        confidence: 0.8,\n        reasoning: '免费看牌',\n        decisionTime: 50,\n        metadata: {\n          handStrength: 0.5,\n          positionFactor: gameData.position,\n          opponentAdjustment: 'standard',\n          playType: 'check'\n        }\n      };\n    }\n\n    return null;\n  }\n\n  // 💾 检查决策缓存\n  private checkDecisionCache(gameData: GameData): CachedDecision | null {\n    const situationKey = this.generateSituationKey(gameData);\n    const cached = this.decisionCache.get(situationKey);\n\n    if (cached && Date.now() - cached.timestamp < 300000) { // 5分钟有效期\n      cached.hitCount++;\n      return cached;\n    }\n\n    return null;\n  }\n\n  // 💾 缓存决策\n  private cacheDecision(gameData: GameData, decision: AIDecision): void {\n    const situationKey = this.generateSituationKey(gameData);\n\n    this.decisionCache.set(situationKey, {\n      situationKey,\n      decision: { ...decision },\n      timestamp: Date.now(),\n      hitCount: 0,\n      confidence: decision.confidence\n    });\n\n    // 限制缓存大小\n    if (this.decisionCache.size > 1000) {\n      const oldestKey = Array.from(this.decisionCache.keys())[0];\n      this.decisionCache.delete(oldestKey);\n    }\n  }\n\n  // 🔑 生成情况键\n  private generateSituationKey(gameData: GameData): string {\n    const handStrength = this.calculateHandStrength(gameData.holeCards);\n    const positionGroup = this.getPositionGroup(gameData.position);\n    const actionType = this.getActionType(gameData.actionSequence);\n    const potOddsGroup = this.getPotOddsGroup(gameData.potOdds);\n\n    return `${handStrength}_${positionGroup}_${actionType}_${potOddsGroup}_${gameData.phase}`;\n  }\n\n  // 🚀 GTO翻前决策\n  private async getGTOPreflopDecision(\n    gameState: NewGameState,\n    playerId: string,\n    holeCards: Card[]\n  ): Promise<AIDecision | null> {\n    try {\n      // 动态导入GTO服务 (避免循环依赖)\n      const { gtoService } = await import('../services/gto-service.ts');\n\n      // 找到当前玩家\n      const currentPlayer = gameState.players.find(p => p.id === playerId);\n      if (!currentPlayer) {\n        throw new Error('找不到当前玩家');\n      }\n\n      // 格式化手牌\n      const hand = gtoService.formatHoleCards(holeCards);\n      if (hand === 'XX') {\n        throw new Error('无效手牌');\n      }\n\n      // 格式化位置\n      const position = gtoService.formatPosition(\n        currentPlayer.position,\n        gameState.players.length,\n        gameState.dealerIndex\n      );\n\n      // 计算筹码深度\n      const stackBB = gtoService.calculateStackDepth(\n        currentPlayer.chips,\n        gameState.bigBlind || 100\n      );\n\n      // 分析面对的行动\n      const facingAction = gtoService.analyzeFacingAction(gameState, playerId);\n\n      // 计算后面的玩家数量\n      const playersBehind = gtoService.calculatePlayersBehind(gameState, playerId);\n\n      // 构建GTO查询\n      const gtoQuery = {\n        hand,\n        position,\n        facing_action: facingAction,\n        players_behind: playersBehind,\n        stack_bb: stackBB\n      };\n\n      console.log(`🔍 GTO查询: ${JSON.stringify(gtoQuery)}`);\n\n      // 获取GTO决策 (移除超时限制)\n      const gtoDecision = await gtoService.getPreflopDecision(gtoQuery);\n\n      // 转换为AI决策格式\n      const aiDecision: AIDecision = {\n        action: gtoDecision.action as any,\n        amount: this.calculateGTOAmount(gtoDecision, gameState),\n        confidence: gtoDecision.frequency,\n        reasoning: `GTO翻前策略: ${gtoDecision.reasoning}`,\n        decisionTime: 0,\n        metadata: {\n          handStrength: this.getHandStrengthFromTier(gtoDecision.hand_tier),\n          positionFactor: currentPlayer.position,\n          opponentAdjustment: 'gto',\n          playType: 'gto_preflop',\n          gtoData: gtoDecision\n        }\n      };\n\n      return aiDecision;\n\n    } catch (error) {\n      console.error('❌ GTO翻前决策失败:', error);\n      return null;\n    }\n  }\n\n  // 计算GTO决策的具体金额\n  private calculateGTOAmount(gtoDecision: any, gameState: NewGameState): number {\n    const bigBlind = gameState.bigBlind || 100;\n\n    switch (gtoDecision.action) {\n      case 'fold':\n        return 0;\n      case 'call':\n        return gameState.currentBet;\n      case 'limp':\n        return bigBlind;\n      case 'raise':\n        return Math.round(gtoDecision.amount * bigBlind);\n      case 'all_in':\n        // 返回一个很大的数字表示全下\n        return 999999;\n      default:\n        return 0;\n    }\n  }\n\n  // 从手牌等级获取强度值\n  private getHandStrengthFromTier(tier: string): number {\n    const tierMap: Record<string, number> = {\n      'PREMIUM': 0.95,\n      'STRONG': 0.8,\n      'MEDIUM': 0.6,\n      'WEAK': 0.4,\n      'SPECULATIVE': 0.3,\n      'TRASH': 0.1,\n      'UNKNOWN': 0.5\n    };\n\n    return tierMap[tier] || 0.5;\n  }\n\n  // 🚨 紧急决策\n  private getEmergencyDecision(gameState: NewGameState, holeCards: Card[]): AIDecision {\n    return {\n      action: 'fold',\n      amount: 0,\n      confidence: 0.5,\n      reasoning: '系统错误，安全弃牌',\n      decisionTime: 0,\n      metadata: {\n        handStrength: 0,\n        positionFactor: 'unknown',\n        opponentAdjustment: 'emergency',\n        playType: 'emergency_fold'\n      }\n    };\n  }\n\n  // 🎯 基础决策\n  private getBasicDecision(gameData: GameData): AIDecision {\n    const handStrength = this.calculateHandStrength(gameData.holeCards);\n\n    if (handStrength > 0.7) {\n      return {\n        action: 'raise',\n        amount: Math.round(Math.max(gameData.currentBet * 2, 100)),\n        confidence: 0.7,\n        reasoning: '强牌基础策略',\n        decisionTime: 1000,\n        metadata: {\n          handStrength,\n          positionFactor: gameData.position,\n          opponentAdjustment: 'basic',\n          playType: 'value'\n        }\n      };\n    } else if (handStrength > 0.4 && gameData.toCall < gameData.pot * 0.3) {\n      return {\n        action: 'call',\n        amount: gameData.toCall,\n        confidence: 0.6,\n        reasoning: '中等牌力跟注',\n        decisionTime: 1000,\n        metadata: {\n          handStrength,\n          positionFactor: gameData.position,\n          opponentAdjustment: 'basic',\n          playType: 'call'\n        }\n      };\n    } else {\n      return {\n        action: 'fold',\n        amount: 0,\n        confidence: 0.8,\n        reasoning: '牌力不足弃牌',\n        decisionTime: 1000,\n        metadata: {\n          handStrength,\n          positionFactor: gameData.position,\n          opponentAdjustment: 'basic',\n          playType: 'fold'\n        }\n      };\n    }\n  }\n\n  // 🔧 辅助方法\n  private getPlayerPosition(gameState: NewGameState, playerId: string): string {\n    const playerIndex = gameState.players.findIndex(p => p.id === playerId);\n    const dealerIndex = gameState.dealerIndex;\n    const totalPlayers = gameState.players.length;\n\n    // 计算相对于庄家的位置\n    const positionIndex = (playerIndex - dealerIndex + totalPlayers) % totalPlayers;\n\n    // 9人桌标准位置顺序：庄家开始顺时针\n    // 位置0: BTN, 位置1: SB, 位置2: BB, 位置3: UTG, 位置4: UTG+1, 位置5: UTG+2, 位置6: MP, 位置7: MP+1, 位置8: CO\n    const positions = ['BTN', 'SB', 'BB', 'UTG', 'UTG+1', 'UTG+2', 'MP', 'MP+1', 'CO'];\n\n    console.log(`🔍 位置计算: 玩家${playerId} playerIndex=${playerIndex}, dealerIndex=${dealerIndex}, positionIndex=${positionIndex}, 位置=${positions[positionIndex]}`);\n\n    return positions[positionIndex] || `POS${positionIndex}`;\n  }\n\n  private formatCards(cards: Card[]): string {\n    return cards.map(card => `${card.rank}${card.suit}`).join(' ');\n  }\n\n  private buildActionSequence(gameState: NewGameState): string {\n    if (!gameState.currentRoundActions || gameState.currentRoundActions.length === 0) {\n      return '游戏开始';\n    }\n\n    return gameState.currentRoundActions\n      .map(action => `${action.playerName}:${action.action}${action.amount ? `(${action.amount})` : ''}`)\n      .join(' → ');\n  }\n\n  private buildCurrentRoundActions(gameState: NewGameState): string {\n    if (!gameState.currentRoundActions || gameState.currentRoundActions.length === 0) {\n      return '本轮暂无行动';\n    }\n\n    return gameState.currentRoundActions\n      .filter(action => action.phase === gameState.phase)\n      .map(action => `${action.playerName} ${action.action} ${action.amount || ''}`)\n      .join(', ');\n  }\n\n  private buildOpponentBehaviorSummary(opponentProfiles: Map<string, OpponentProfile>): string {\n    const summaries: string[] = [];\n    opponentProfiles.forEach(profile => {\n      const recentActions = profile.recentActions.slice(-3);\n      if (recentActions.length > 0) {\n        summaries.push(`${profile.playerName}: ${recentActions.map(a => a.action).join(',')}`);\n      }\n    });\n    return summaries.join('; ');\n  }\n\n  private analyzeBoardTexture(communityCards: Card[]): string {\n    if (communityCards.length === 0) return 'preflop';\n\n    // 简化的牌面纹理分析\n    const suits = communityCards.map(c => c.suit);\n    const ranks = communityCards.map(c => c.rank);\n\n    const isFlushDraw = suits.some(suit => suits.filter(s => s === suit).length >= 2);\n    const isStraightDraw = this.hasStraightDraw(ranks);\n\n    if (isFlushDraw && isStraightDraw) return 'wet';\n    if (isFlushDraw || isStraightDraw) return 'semi-wet';\n    return 'dry';\n  }\n\n  private isDrawHeavyBoard(communityCards: Card[]): boolean {\n    return this.analyzeBoardTexture(communityCards) === 'wet';\n  }\n\n  private hasStraightDraw(ranks: string[]): boolean {\n    // 简化实现\n    const values = ranks.map(r => this.getCardRankValue(r)).sort((a, b) => a - b);\n    for (let i = 0; i < values.length - 1; i++) {\n      if (values[i + 1] - values[i] === 1) return true;\n    }\n    return false;\n  }\n\n  private calculateHandStrength(holeCardsStr: string): number {\n    // 简化的手牌强度计算\n    const cards = holeCardsStr.split(' ');\n    if (cards.length !== 2) return 0.5;\n\n    const [card1, card2] = cards;\n    const rank1 = this.getCardRankValue(card1[0]);\n    const rank2 = this.getCardRankValue(card2[0]);\n    const suited = card1[1] === card2[1];\n\n    let strength = Math.max(rank1, rank2) / 14;\n\n    if (rank1 === rank2) strength += 0.3; // 对子加成\n    if (suited) strength += 0.1; // 同花加成\n\n    return Math.min(strength, 1);\n  }\n\n  private getCardRankValue(rank: string): number {\n    const values: { [key: string]: number } = {\n      '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,\n      'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14\n    };\n    return values[rank] || 0;\n  }\n\n  private isNutsHand(holeCards: string, board?: string): boolean {\n    // 简化实现 - 检查是否是超强牌\n    const handStrength = this.calculateHandStrength(holeCards);\n    return handStrength > 0.9;\n  }\n\n  private isTrashHand(holeCards: string): boolean {\n    const handStrength = this.calculateHandStrength(holeCards);\n    return handStrength < 0.2;\n  }\n\n  private getPositionGroup(position: string): string {\n    if (['UTG', 'UTG+1', 'UTG+2'].includes(position)) return 'early';\n    if (['MP', 'MP+1'].includes(position)) return 'middle';\n    return 'late';\n  }\n\n  private getActionType(actionSequence: string): string {\n    if (actionSequence.includes('raise') || actionSequence.includes('bet')) return 'aggressive';\n    if (actionSequence.includes('call')) return 'passive';\n    return 'unopened';\n  }\n\n  private getPotOddsGroup(potOdds: string): string {\n    const odds = parseFloat(potOdds.split(':')[0]);\n    if (odds > 3) return 'good';\n    if (odds > 2) return 'fair';\n    return 'poor';\n  }\n}\n\n// 🎯 Prompt管理器\nclass PromptManager {\n  generateDecisionPrompt(gameData: GameData): string {\n    if (gameData.phase === 'preflop') {\n      return this.generatePreflopPrompt(gameData);\n    } else {\n      return this.generatePostflopPrompt(gameData);\n    }\n  }\n\n  private generatePreflopPrompt(gameData: GameData): string {\n    return `你是PokerGPT-Pro，世界顶级德州扑克AI。当前9人桌，盲注50/100。\n\n**当前局面** (翻牌前):\n位置: ${gameData.position} (${gameData.positionIndex}/9)\n手牌: ${gameData.holeCards}\n筹码: ${gameData.myChips} (${(gameData.myChips/100).toFixed(1)}BB)\n底池: ${gameData.pot}\n当前下注: ${gameData.currentBet}\n需要跟注: ${gameData.toCall}\n\n**行动序列**: ${gameData.actionSequence}\n**活跃玩家**: ${gameData.activePlayers}/${gameData.totalPlayers}\n\n**对手档案**:\n${gameData.opponentProfiles.map(p =>\n  `${p.name}(${p.position}): VPIP${p.vpip}% PFR${p.pfr}% 激进度${p.aggression}/10 ${p.tendency}`\n).join('\\n')}\n\n**快速分析要求**:\n1. 手牌强度评级(1-10)\n2. 位置优势评估\n3. 对手行为读取\n4. 底池赔率计算\n5. GTO基础策略+对手调整\n\n**时间限制**: ${gameData.timeLimit}ms内决策\n\n返回格式:\n{\n  \"action\": \"fold/call/raise\",\n  \"amount\": 数字,\n  \"confidence\": 0.8,\n  \"reasoning\": \"简洁推理(20字内)\",\n  \"hand_strength\": 7,\n  \"position_factor\": \"early/middle/late\",\n  \"opponent_adjustment\": \"tighter/standard/looser\"\n}`;\n  }\n\n  private generatePostflopPrompt(gameData: GameData): string {\n    return `PokerGPT-Pro翻牌后分析 - 9人桌盲注50/100\n\n**牌面信息**:\n手牌: ${gameData.holeCards}\n公共牌: ${gameData.board}\n牌面纹理: ${gameData.boardTexture} (${gameData.drawHeavy ? '听牌多' : '听牌少'})\n\n**当前状况**:\n位置: ${gameData.position} (${gameData.positionIndex}/9)\n底池: ${gameData.pot} (${(gameData.pot/100).toFixed(1)}BB)\n筹码: ${gameData.myChips} (${(gameData.myChips/100).toFixed(1)}BB)\n当前下注: ${gameData.currentBet}\n需要跟注: ${gameData.toCall}\n底池赔率: ${gameData.potOdds}\n\n**本轮行动**: ${gameData.currentRoundActions}\n**对手行为模式**: ${gameData.recentOpponentBehavior}\n\n**快速评估**:\n1. 牌力等级(nuts/strong/medium/weak/air)\n2. 听牌可能性\n3. 对手可能范围\n4. 价值下注vs诈唬平衡\n5. 对手倾向调整\n\n**时间限制**: ${gameData.timeLimit}ms内决策\n\n返回:\n{\n  \"action\": \"fold/check/call/bet/raise\",\n  \"amount\": 数字,\n  \"confidence\": 0.85,\n  \"reasoning\": \"简洁推理\",\n  \"hand_category\": \"strong\",\n  \"opponent_likely_range\": \"medium-strong\",\n  \"play_type\": \"value/bluff/protection\"\n}`;\n  }\n}\n\n// 📊 性能追踪器\nclass PerformanceTracker {\n  private playerMetrics: Map<string, PlayerMetrics> = new Map();\n\n  recordDecision(playerId: string, time: number, confidence: number): void {\n    let metrics = this.playerMetrics.get(playerId);\n    if (!metrics) {\n      metrics = {\n        totalDecisions: 0,\n        totalTime: 0,\n        averageTime: 0,\n        averageConfidence: 0,\n        fastDecisions: 0, // <1秒\n        slowDecisions: 0  // >10秒\n      };\n      this.playerMetrics.set(playerId, metrics);\n    }\n\n    metrics.totalDecisions++;\n    metrics.totalTime += time;\n    metrics.averageTime = metrics.totalTime / metrics.totalDecisions;\n    metrics.averageConfidence =\n      (metrics.averageConfidence * (metrics.totalDecisions - 1) + confidence) / metrics.totalDecisions;\n\n    if (time < 1000) metrics.fastDecisions++;\n    if (time > 10000) metrics.slowDecisions++;\n\n    console.log(`📊 性能记录: ${playerId} - ${time}ms, 信心度: ${confidence.toFixed(2)}`);\n  }\n\n  getPlayerMetrics(playerId: string): PlayerMetrics | undefined {\n    return this.playerMetrics.get(playerId);\n  }\n\n  getAllMetrics(): Map<string, PlayerMetrics> {\n    return new Map(this.playerMetrics);\n  }\n}\n\ninterface PlayerMetrics {\n  totalDecisions: number;\n  totalTime: number;\n  averageTime: number;\n  averageConfidence: number;\n  fastDecisions: number;\n  slowDecisions: number;\n}\n"],"names":["AdaptivePromptManager","generatePrompt","gameState","playerId","holeCards","complexityLevel","timeLimit","temperature","this","generateMinimalPrompt","generateStandardPrompt","generateDetailedPrompt","generateComprehensivePrompt","player","players","find","p","id","handStr","rank","suit","pot","toCall","getAmountToCall","stack","chips","getBoardString","communityCards","position","getPlayerPosition","opponents","getActionHistory","getActiveOpponents","length","phase","JSON","stringify","currentBet","bigBlind","board","map","c","myPosition","myChips","myCards","potOdds","toFixed","detailedBettingHistory","buildDetailedBettingSequence","currentRoundSummary","buildCurrentRoundSummary","opp","name","isActive","style","gameFormat","blinds","smallBlind","tableSize","gameType","stackToPotRatio","stackBB","Math","round","boardAnalysis","texture","analyzeBoardTexture","drawPossible","pairedBoard","isPairedBoard","effectiveStacks","min","completeActionHistory","currentRoundAnalysis","expertAnalysis","boardTexture","flushPossible","isFlushPossible","straightPossible","isStraightPossible","join","totalPlayers","dealerIndex","relativePosition","max","console","log","history","actionHistory","原始长度","原始数据","gameState类型","gameState键","Object","keys","第一个行动示例","convertedHistory","action","playerName","amount","timestamp","转换后长度","转换后数据","第一个转换示例","filter","suits","ranks","suitCounts","reduce","acc","flushDraw","values","rankValues","parseInt","sort","a","b","straightDraw","i","_gameState$actionHist","actionHistory字段","actionHistory长度","actionHistory类型","preflop","flop","turn","river","summary","actionsByPhase","formatActions","actions","result","allActions","currentPhaseActions","actionSummary","rankCounts","some","count","calculatePotOdds","calculateSPR","getStackSizes","getOpponentProfiles","analyzeGameFlow","postflop","aggression","getPositionDetails","calculateImpliedOdds","calculateReverseImpliedOdds","AIAPIPool","constructor","apiConfig","poolSize","arguments","undefined","connections","currentConnectionIndex","requestQueue","isProcessingQueue","initializeConnections","startQueueProcessor","baseConfig","connection","config","requestCount","errorCount","averageResponseTime","lastUsed","push","makeDecisionRequest","prompt","_this$connections$","makeDecisionRequestWithConfig","startTime","Date","now","selectBestConnection","response","makeAPIRequestWithConfig","decision","parseAIResponse","updateConnectionStats","error","tryBackupRequestWithConfig","makeParallelRequest","Error","activeConnections","best","current","bestScore","calculateConnectionScore","makeAPIRequest","controller","AbortController","timeoutId","setTimeout","abort","fetch","baseUrl","method","headers","apiKey","body","model","messages","role","content","max_tokens","maxTokens","stream","signal","clearTimeout","ok","status","statusText","data","json","choices","message","responseText","jsonMatch","match","jsonStr","parsed","parse","includes","confidence","reasoning","decisionTime","metadata","handStrength","hand_strength","positionFactor","position_factor","opponentAdjustment","opponent_adjustment","playType","play_type","tryBackupRequest","_this$connections$2","remainingTime","backupConnections","getEmergencyDecision","responseTime","success","warn","setInterval","processRequestQueue","request","shift","resolve","reject","getPoolStatus","totalRequests","sum","totalErrors","totalConnections","successRate","queueLength","cleanup","forEach","SituationComplexityAnalyzer","analyzeSituation","_gameState$players","phaseType","gameStateKeys","hasPhase","gameStateStructure","gameId","baseScore","potBBs","activeOpponents","totalScore","factors","handStrengthAmbiguity","floor","opponentRangeWidth","actionSequenceComplexity","stackAndPotDynamics","category","categorizeComplexity","recommendedTimeout","getRecommendedTimeout","recommendedTemperature","getRecommendedTemperature","promptType","getPromptType","score","FastDecisionEngine","decisionCache","Map","apiPool","promptManager","performanceTracker","complexityAnalyzer","adaptivePromptManager","poolConfig","timeout","PromptManager","PerformanceTracker","makeDecision","opponentProfiles","gtoDecision","getGTOPreflopDecision","totalTime","gtoError","gameData","buildGameData","executeLayeredDecision","recordDecision","positionIndex","findIndex","opponentSummaries","profile","get","vpip","pfr","tendency","actionSequence","buildActionSequence","formatCards","activePlayers","drawHeavy","isDrawHeavyBoard","currentRoundActions","buildCurrentRoundActions","recentOpponentBehavior","buildOpponentBehaviorSummary","strategicDecision","performStrategicAnalysis","applyFineTuning","tryQuickDecision","cachedDecision","checkDecisionCache","obviousDecision","checkObviousDecisions","elapsed","complexityAssessment","dynamicTimeLimit","adaptivePrompt","complexityScore","complexityCategory","cacheDecision","fallbackDecision","getBasicDecision","random","isNutsHand","isTrashHand","situationKey","generateSituationKey","cached","hitCount","set","size","oldestKey","Array","from","delete","calculateHandStrength","getPositionGroup","getActionType","getPotOddsGroup","gtoService","currentPlayer","hand","formatHoleCards","formatPosition","calculateStackDepth","facingAction","analyzeFacingAction","gtoQuery","facing_action","players_behind","calculatePlayersBehind","stack_bb","getPreflopDecision","calculateGTOAmount","frequency","getHandStrengthFromTier","hand_tier","gtoData","tier","playerIndex","positions","cards","card","summaries","recentActions","slice","isFlushDraw","s","isStraightDraw","hasStraightDraw","r","getCardRankValue","holeCardsStr","split","card1","card2","rank1","rank2","suited","strength","odds","parseFloat","generateDecisionPrompt","generatePreflopPrompt","generatePostflopPrompt","playerMetrics","time","metrics","totalDecisions","averageTime","averageConfidence","fastDecisions","slowDecisions","getPlayerMetrics","getAllMetrics"],"sourceRoot":""}