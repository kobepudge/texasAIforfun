{"version":3,"file":"static/js/397.63036725.chunk.js","mappings":"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","sources":["core/event-bus.ts","ai/ai-player.ts","ai/ai-instance-manager.ts"],"sourcesContent":["// 🚀 增强的事件总线系统\n\nexport interface PokerEvent {\n  id: string;\n  type: PokerEventType;\n  playerId?: string;\n  data: any;\n  timestamp: number;\n  priority: EventPriority;\n}\n\nexport enum PokerEventType {\n  // 游戏生命周期\n  GAME_INITIALIZED = 'game_initialized',\n  GAME_STARTED = 'game_started',\n  GAME_ENDED = 'game_ended',\n  ROUND_STARTED = 'round_started',\n  ROUND_ENDED = 'round_ended',\n  \n  // 玩家事件\n  PLAYER_JOINED = 'player_joined',\n  PLAYER_LEFT = 'player_left',\n  PLAYER_ACTION = 'player_action',\n  PLAYER_TURN_START = 'player_turn_start',\n  PLAYER_TURN_END = 'player_turn_end',\n  PLAYER_ELIMINATED = 'player_eliminated',\n  \n  // 牌局事件\n  CARDS_DEALT = 'cards_dealt',\n  COMMUNITY_CARDS_REVEALED = 'community_cards_revealed',\n  BLINDS_POSTED = 'blinds_posted',\n  POT_UPDATED = 'pot_updated',\n  PHASE_CHANGED = 'phase_changed',\n  \n  // AI事件\n  AI_DECISION_START = 'ai_decision_start',\n  AI_DECISION_COMPLETE = 'ai_decision_complete',\n  AI_DECISION_TIMEOUT = 'ai_decision_timeout',\n  AI_ANALYSIS_UPDATE = 'ai_analysis_update',\n  \n  // 性能事件\n  PERFORMANCE_METRIC = 'performance_metric',\n  ERROR_OCCURRED = 'error_occurred',\n  WARNING_ISSUED = 'warning_issued'\n}\n\nexport enum EventPriority {\n  CRITICAL = 0,    // 游戏核心逻辑\n  HIGH = 1,        // 玩家行动\n  MEDIUM = 2,      // AI决策\n  LOW = 3,         // 统计和监控\n  DEBUG = 4        // 调试信息\n}\n\nexport type EventHandler = (event: PokerEvent) => void | Promise<void>;\n\n// 🎯 事件过滤器\nexport interface EventFilter {\n  types?: PokerEventType[];\n  playerId?: string;\n  priority?: EventPriority;\n  timeRange?: { start: number; end: number };\n}\n\n// 📊 事件统计\nexport interface EventStats {\n  totalEvents: number;\n  eventsByType: Map<PokerEventType, number>;\n  eventsByPriority: Map<EventPriority, number>;\n  averageProcessingTime: number;\n  errorCount: number;\n}\n\n// 🚀 增强的事件总线\nexport class EnhancedEventBus {\n  private handlers: Map<PokerEventType, EventHandler[]> = new Map();\n  private eventHistory: PokerEvent[] = [];\n  private eventQueue: PokerEvent[] = [];\n  private isProcessing: boolean = false;\n  private stats: EventStats;\n  private maxHistorySize: number = 1000;\n\n  constructor() {\n    this.stats = {\n      totalEvents: 0,\n      eventsByType: new Map(),\n      eventsByPriority: new Map(),\n      averageProcessingTime: 0,\n      errorCount: 0\n    };\n\n    // 启动事件处理循环\n    this.startEventProcessing();\n  }\n\n  // 📝 订阅事件\n  subscribe(eventType: PokerEventType, handler: EventHandler): () => void {\n    if (!this.handlers.has(eventType)) {\n      this.handlers.set(eventType, []);\n    }\n    \n    this.handlers.get(eventType)!.push(handler);\n    \n    console.log(`📝 订阅事件: ${eventType}`);\n    \n    // 返回取消订阅函数\n    return () => {\n      const handlers = this.handlers.get(eventType);\n      if (handlers) {\n        const index = handlers.indexOf(handler);\n        if (index > -1) {\n          handlers.splice(index, 1);\n        }\n      }\n    };\n  }\n\n  // 🚀 发布事件\n  emit(eventType: PokerEventType, data: any, playerId?: string, priority: EventPriority = EventPriority.MEDIUM): void {\n    const event: PokerEvent = {\n      id: this.generateEventId(),\n      type: eventType,\n      playerId,\n      data,\n      timestamp: Date.now(),\n      priority\n    };\n\n    // 添加到队列\n    this.eventQueue.push(event);\n    \n    // 按优先级排序\n    this.eventQueue.sort((a, b) => a.priority - b.priority);\n    \n    console.log(`🚀 事件入队: ${eventType} (优先级: ${priority})`);\n  }\n\n  // ⚡ 立即发布事件（跳过队列）\n  emitImmediate(eventType: PokerEventType, data: any, playerId?: string): void {\n    const event: PokerEvent = {\n      id: this.generateEventId(),\n      type: eventType,\n      playerId,\n      data,\n      timestamp: Date.now(),\n      priority: EventPriority.CRITICAL\n    };\n\n    this.processEvent(event);\n  }\n\n  // 🔄 事件处理循环\n  private startEventProcessing(): void {\n    setInterval(() => {\n      if (!this.isProcessing && this.eventQueue.length > 0) {\n        this.processNextEvent();\n      }\n    }, 10); // 每10ms检查一次\n  }\n\n  // 📤 处理下一个事件\n  private async processNextEvent(): Promise<void> {\n    if (this.eventQueue.length === 0) return;\n\n    this.isProcessing = true;\n    const event = this.eventQueue.shift()!;\n    \n    await this.processEvent(event);\n    \n    this.isProcessing = false;\n  }\n\n  // 🎯 处理单个事件\n  private async processEvent(event: PokerEvent): Promise<void> {\n    const startTime = Date.now();\n    \n    try {\n      // 添加到历史记录\n      this.addToHistory(event);\n      \n      // 获取处理器\n      const handlers = this.handlers.get(event.type) || [];\n      \n      // 并行执行所有处理器\n      const promises = handlers.map(async (handler) => {\n        try {\n          await handler(event);\n        } catch (error) {\n          console.error(`❌ 事件处理器错误 ${event.type}:`, error);\n          this.stats.errorCount++;\n        }\n      });\n      \n      await Promise.all(promises);\n      \n      // 更新统计\n      this.updateStats(event, Date.now() - startTime);\n      \n    } catch (error) {\n      console.error(`❌ 事件处理失败 ${event.type}:`, error);\n      this.stats.errorCount++;\n    }\n  }\n\n  // 📚 添加到历史记录\n  private addToHistory(event: PokerEvent): void {\n    this.eventHistory.push(event);\n    \n    // 限制历史记录大小\n    if (this.eventHistory.length > this.maxHistorySize) {\n      this.eventHistory.shift();\n    }\n  }\n\n  // 📊 更新统计信息\n  private updateStats(event: PokerEvent, processingTime: number): void {\n    this.stats.totalEvents++;\n    \n    // 按类型统计\n    const typeCount = this.stats.eventsByType.get(event.type) || 0;\n    this.stats.eventsByType.set(event.type, typeCount + 1);\n    \n    // 按优先级统计\n    const priorityCount = this.stats.eventsByPriority.get(event.priority) || 0;\n    this.stats.eventsByPriority.set(event.priority, priorityCount + 1);\n    \n    // 更新平均处理时间\n    this.stats.averageProcessingTime = \n      (this.stats.averageProcessingTime * (this.stats.totalEvents - 1) + processingTime) / this.stats.totalEvents;\n  }\n\n  // 🔍 查询事件历史\n  getEventHistory(filter?: EventFilter): PokerEvent[] {\n    let events = [...this.eventHistory];\n    \n    if (filter) {\n      if (filter.types) {\n        events = events.filter(e => filter.types!.includes(e.type));\n      }\n      \n      if (filter.playerId) {\n        events = events.filter(e => e.playerId === filter.playerId);\n      }\n      \n      if (filter.priority !== undefined) {\n        events = events.filter(e => e.priority === filter.priority);\n      }\n      \n      if (filter.timeRange) {\n        events = events.filter(e => \n          e.timestamp >= filter.timeRange!.start && \n          e.timestamp <= filter.timeRange!.end\n        );\n      }\n    }\n    \n    return events;\n  }\n\n  // 📊 获取统计信息\n  getStats(): EventStats {\n    return { ...this.stats };\n  }\n\n  // 🧹 清理历史记录\n  clearHistory(): void {\n    this.eventHistory = [];\n    console.log('🧹 事件历史已清理');\n  }\n\n  // 🔧 生成事件ID\n  private generateEventId(): string {\n    return `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  // 📈 获取性能报告\n  getPerformanceReport(): string {\n    const stats = this.getStats();\n    \n    return `\n📈 事件总线性能报告\n==================\n总事件数: ${stats.totalEvents}\n平均处理时间: ${stats.averageProcessingTime.toFixed(2)}ms\n错误数量: ${stats.errorCount}\n队列长度: ${this.eventQueue.length}\n\n事件类型分布:\n${Array.from(stats.eventsByType.entries())\n  .map(([type, count]) => `  ${type}: ${count}`)\n  .join('\\n')}\n\n优先级分布:\n${Array.from(stats.eventsByPriority.entries())\n  .map(([priority, count]) => `  ${EventPriority[priority]}: ${count}`)\n  .join('\\n')}\n`;\n  }\n}\n\n// 🌟 全局事件总线实例\nexport const globalEventBus = new EnhancedEventBus();\n\n// 🎯 便捷的事件发布函数\nexport const emitGameEvent = (type: PokerEventType, data: any, playerId?: string, priority?: EventPriority) => {\n  globalEventBus.emit(type, data, playerId, priority);\n};\n\nexport const emitCriticalEvent = (type: PokerEventType, data: any, playerId?: string) => {\n  globalEventBus.emitImmediate(type, data, playerId);\n};\n","import { PokerEventType, globalEventBus } from '../core/event-bus.ts';\nimport { NewGameState } from '../core/game-engine.ts';\nimport { Card } from '../types/poker';\n\n// 🤖 AI玩家配置\nexport interface AIPlayerConfig {\n  id: string;\n  name: string;\n  personality: AIPersonality;\n  apiConfig: AIAPIConfig;\n  decisionTimeoutMs: number;\n}\n\nexport interface AIAPIConfig {\n  apiKey: string;\n  baseUrl: string;\n  model: string;\n  temperature: number;\n  maxTokens: number;\n}\n\nexport interface AIPersonality {\n  aggression: number;      // 激进度 0-1\n  tightness: number;       // 紧密度 0-1\n  bluffFrequency: number;  // 诈唬频率 0-1\n  adaptability: number;    // 适应性 0-1\n  riskTolerance: number;   // 风险承受度 0-1\n}\n\n// 🎯 决策结果\nexport interface AIDecision {\n  action: 'fold' | 'check' | 'call' | 'bet' | 'raise' | 'all-in';\n  amount: number;\n  confidence: number;\n  reasoning: string;\n  decisionTime: number;\n  metadata: {\n    handStrength: number;\n    positionFactor: string;\n    opponentAdjustment: string;\n    playType: string;\n  };\n}\n\n// 🧠 对手档案\nexport interface OpponentProfile {\n  playerId: string;\n  playerName: string;\n  vpip: number;           // 入池率\n  pfr: number;            // 翻牌前加注率\n  aggression: number;     // 激进度指数\n  tightness: number;      // 紧密度\n  bluffFrequency: number; // 诈唬频率\n  positionAwareness: number; // 位置意识\n  recentActions: RecentAction[];\n  lastUpdate: number;\n  tendency: 'LAG' | 'TAG' | 'LP' | 'TP'; // Loose Aggressive, Tight Aggressive, Loose Passive, Tight Passive\n}\n\nexport interface RecentAction {\n  action: string;\n  amount: number;\n  position: string;\n  phase: string;\n  outcome: string;\n  timestamp: number;\n}\n\n// 🤖 AI玩家类\nexport class AIPlayer {\n  private config: AIPlayerConfig;\n  private gameState: NewGameState | null = null;\n  private holeCards: Card[] = [];\n  private opponentProfiles: Map<string, OpponentProfile> = new Map();\n  private decisionHistory: AIDecision[] = [];\n  private isActive: boolean = false;\n  private currentDecisionPromise: Promise<AIDecision> | null = null;\n\n  constructor(config: AIPlayerConfig) {\n    this.config = config;\n    this.setupEventListeners();\n    \n    console.log(`🤖 AI玩家创建: ${config.name}`);\n    console.log(`🎭 性格特征:`, config.personality);\n  }\n\n  // 🎧 设置事件监听\n  private setupEventListeners(): void {\n    // 监听游戏开始\n    globalEventBus.subscribe(PokerEventType.GAME_STARTED, (event) => {\n      this.onGameStarted(event.data);\n    });\n\n    // 监听发牌\n    globalEventBus.subscribe(PokerEventType.CARDS_DEALT, (event) => {\n      if (event.playerId === this.config.id) {\n        this.onCardsDealt(event.data.cards);\n      }\n    });\n\n    // 监听轮到自己\n    globalEventBus.subscribe(PokerEventType.PLAYER_TURN_START, (event) => {\n      if (event.playerId === this.config.id) {\n        this.onMyTurn(event.data);\n      }\n    });\n\n    // 监听其他玩家行动\n    globalEventBus.subscribe(PokerEventType.PLAYER_ACTION, (event) => {\n      if (event.playerId !== this.config.id) {\n        this.onOpponentAction(event.data);\n      }\n    });\n  }\n\n  // 🚀 游戏开始\n  private onGameStarted(data: any): void {\n    this.isActive = true;\n    this.gameState = data.gameState;\n    this.initializeOpponentProfiles();\n    \n    console.log(`🚀 ${this.config.name} 加入游戏`);\n  }\n\n  // 🃏 收到手牌\n  private onCardsDealt(cards: Card[]): void {\n    this.holeCards = cards;\n    \n    console.log(`🃏 ${this.config.name} 收到手牌: ${this.formatCards(cards)}`);\n    \n    // 立即开始分析\n    this.analyzeHoleCards();\n  }\n\n  // 🎯 轮到自己行动\n  private async onMyTurn(data: any): Promise<void> {\n    if (!this.isActive || !this.gameState) return;\n\n    console.log(`🎯 轮到 ${this.config.name} 行动`);\n    \n    // 发送AI决策开始事件\n    globalEventBus.emit(PokerEventType.AI_DECISION_START, {\n      playerId: this.config.id,\n      playerName: this.config.name,\n      gameState: this.gameState\n    }, this.config.id);\n\n    try {\n      // 开始决策\n      const decision = await this.makeDecision();\n      \n      // 发送AI决策完成事件\n      globalEventBus.emit(PokerEventType.AI_DECISION_COMPLETE, {\n        playerId: this.config.id,\n        playerName: this.config.name,\n        decision\n      }, this.config.id);\n\n      // 执行决策\n      this.executeDecision(decision);\n      \n    } catch (error) {\n      console.error(`❌ ${this.config.name} 决策失败:`, error);\n      \n      // 发送超时事件\n      globalEventBus.emit(PokerEventType.AI_DECISION_TIMEOUT, {\n        playerId: this.config.id,\n        playerName: this.config.name,\n        error: error.message\n      }, this.config.id);\n\n      // 执行默认决策（弃牌）\n      this.executeDecision({\n        action: 'fold',\n        amount: 0,\n        confidence: 0,\n        reasoning: '决策超时，自动弃牌',\n        decisionTime: this.config.decisionTimeoutMs,\n        metadata: {\n          handStrength: 0,\n          positionFactor: 'unknown',\n          opponentAdjustment: 'none',\n          playType: 'fold'\n        }\n      });\n    }\n  }\n\n  // 👀 观察对手行动\n  private onOpponentAction(actionData: any): void {\n    this.updateOpponentProfile(actionData);\n  }\n\n  // 🧠 分析手牌\n  private analyzeHoleCards(): void {\n    if (this.holeCards.length !== 2) return;\n\n    const handStrength = this.calculateHandStrength(this.holeCards);\n    const playability = this.calculatePlayability(this.holeCards);\n    \n    console.log(`🧠 ${this.config.name} 手牌分析:`);\n    console.log(`   强度: ${handStrength.toFixed(2)}`);\n    console.log(`   可玩性: ${playability.toFixed(2)}`);\n  }\n\n  // 🎲 做出决策\n  private async makeDecision(): Promise<AIDecision> {\n    const startTime = Date.now();\n    \n    // 设置超时\n    const timeoutPromise = new Promise<AIDecision>((_, reject) => {\n      setTimeout(() => {\n        reject(new Error('决策超时'));\n      }, this.config.decisionTimeoutMs);\n    });\n\n    // 实际决策逻辑\n    const decisionPromise = this.performDecisionAnalysis();\n    \n    // 竞速：决策 vs 超时\n    this.currentDecisionPromise = Promise.race([decisionPromise, timeoutPromise]);\n    \n    const decision = await this.currentDecisionPromise;\n    decision.decisionTime = Date.now() - startTime;\n    \n    // 记录决策历史\n    this.decisionHistory.push(decision);\n    \n    return decision;\n  }\n\n  // 🔍 执行决策分析\n  private async performDecisionAnalysis(): Promise<AIDecision> {\n    // 这里是简化版本，后续会实现完整的AI决策逻辑\n    const handStrength = this.calculateHandStrength(this.holeCards);\n    const position = this.getMyPosition();\n    const potOdds = this.calculatePotOdds();\n    \n    console.log(`🔍 ${this.config.name} 决策分析:`);\n    console.log(`   手牌强度: ${handStrength.toFixed(2)}`);\n    console.log(`   位置: ${position}`);\n    console.log(`   底池赔率: ${potOdds.toFixed(2)}`);\n\n    // 简单决策逻辑（后续会被AI替换）\n    let action: AIDecision['action'] = 'fold';\n    let amount = 0;\n    let confidence = 0.5;\n    let reasoning = '基础决策逻辑';\n\n    if (handStrength > 0.8) {\n      action = 'raise';\n      amount = this.gameState!.bigBlind * 3;\n      confidence = 0.9;\n      reasoning = '强牌加注';\n    } else if (handStrength > 0.6) {\n      action = 'call';\n      confidence = 0.7;\n      reasoning = '中等牌力跟注';\n    } else if (handStrength > 0.4 && potOdds > 2.0) {\n      action = 'call';\n      confidence = 0.6;\n      reasoning = '底池赔率合适';\n    } else {\n      action = 'fold';\n      confidence = 0.8;\n      reasoning = '牌力不足弃牌';\n    }\n\n    return {\n      action,\n      amount,\n      confidence,\n      reasoning,\n      decisionTime: 0, // 会在外层设置\n      metadata: {\n        handStrength,\n        positionFactor: position,\n        opponentAdjustment: 'standard',\n        playType: action === 'raise' ? 'value' : action === 'call' ? 'call' : 'fold'\n      }\n    };\n  }\n\n  // ⚡ 执行决策\n  private executeDecision(decision: AIDecision): void {\n    console.log(`⚡ ${this.config.name} 执行决策: ${decision.action} ${decision.amount || ''}`);\n    console.log(`   推理: ${decision.reasoning}`);\n    console.log(`   信心: ${(decision.confidence * 100).toFixed(1)}%`);\n    console.log(`   耗时: ${decision.decisionTime}ms`);\n\n    // 发送玩家行动事件\n    globalEventBus.emit(PokerEventType.PLAYER_ACTION, {\n      playerId: this.config.id,\n      playerName: this.config.name,\n      action: decision.action,\n      amount: decision.amount,\n      reasoning: decision.reasoning,\n      confidence: decision.confidence\n    }, this.config.id);\n  }\n\n  // 🏗️ 初始化对手档案\n  private initializeOpponentProfiles(): void {\n    if (!this.gameState) return;\n\n    this.gameState.players.forEach(player => {\n      if (player.id !== this.config.id) {\n        this.opponentProfiles.set(player.id, {\n          playerId: player.id,\n          playerName: player.name,\n          vpip: 25, // 默认值\n          pfr: 18,\n          aggression: 1.5,\n          tightness: 0.5,\n          bluffFrequency: 0.2,\n          positionAwareness: 0.5,\n          recentActions: [],\n          lastUpdate: Date.now(),\n          tendency: 'TAG'\n        });\n      }\n    });\n\n    console.log(`🏗️ ${this.config.name} 初始化了 ${this.opponentProfiles.size} 个对手档案`);\n  }\n\n  // 📊 更新对手档案\n  private updateOpponentProfile(actionData: any): void {\n    const profile = this.opponentProfiles.get(actionData.playerId);\n    if (!profile) return;\n\n    // 添加最近行动\n    profile.recentActions.push({\n      action: actionData.action,\n      amount: actionData.amount,\n      position: actionData.position || 'unknown',\n      phase: this.gameState?.phase || 'unknown',\n      outcome: 'pending',\n      timestamp: Date.now()\n    });\n\n    // 限制历史记录长度\n    if (profile.recentActions.length > 20) {\n      profile.recentActions.shift();\n    }\n\n    profile.lastUpdate = Date.now();\n\n    console.log(`📊 ${this.config.name} 更新对手档案: ${profile.playerName}`);\n  }\n\n  // 🧮 计算手牌强度\n  private calculateHandStrength(cards: Card[]): number {\n    if (cards.length !== 2) return 0;\n\n    // 简化的手牌强度计算（基于Chen公式）\n    const [card1, card2] = cards;\n    const rank1 = this.getCardRankValue(card1.rank);\n    const rank2 = this.getCardRankValue(card2.rank);\n    \n    let strength = Math.max(rank1, rank2);\n    \n    // 对子加成\n    if (rank1 === rank2) {\n      strength += rank1;\n    }\n    \n    // 同花加成\n    if (card1.suit === card2.suit) {\n      strength += 2;\n    }\n    \n    // 连牌加成\n    const gap = Math.abs(rank1 - rank2);\n    if (gap <= 4) {\n      strength += (5 - gap);\n    }\n    \n    // 标准化到0-1\n    return Math.min(strength / 20, 1);\n  }\n\n  // 🎯 计算可玩性\n  private calculatePlayability(cards: Card[]): number {\n    // 简化实现\n    return this.calculateHandStrength(cards) * (0.8 + this.config.personality.aggression * 0.4);\n  }\n\n  // 📍 获取自己的位置\n  private getMyPosition(): string {\n    if (!this.gameState) return 'unknown';\n    \n    const myIndex = this.gameState.players.findIndex(p => p.id === this.config.id);\n    const dealerIndex = this.gameState.dealerIndex;\n    const totalPlayers = this.gameState.players.length;\n    \n    const positionIndex = (myIndex - dealerIndex + totalPlayers) % totalPlayers;\n    const positions = ['BTN', 'SB', 'BB', 'UTG', 'UTG+1', 'UTG+2', 'MP', 'MP+1', 'CO'];\n    \n    return positions[positionIndex] || `POS${positionIndex}`;\n  }\n\n  // 💰 计算底池赔率\n  private calculatePotOdds(): number {\n    if (!this.gameState) return 0;\n    \n    const toCall = this.gameState.currentBet; // 简化\n    const potSize = this.gameState.pot;\n    \n    return potSize / (toCall || 1);\n  }\n\n  // 🃏 格式化牌面\n  private formatCards(cards: Card[]): string {\n    return cards.map(card => `${card.rank}${card.suit}`).join(' ');\n  }\n\n  // 🔢 获取牌面数值\n  private getCardRankValue(rank: string): number {\n    const values: { [key: string]: number } = {\n      '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9,\n      'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14\n    };\n    return values[rank] || 0;\n  }\n\n  // 🎯 公共接口\n  getId(): string {\n    return this.config.id;\n  }\n\n  getName(): string {\n    return this.config.name;\n  }\n\n  getOpponentProfiles(): Map<string, OpponentProfile> {\n    return new Map(this.opponentProfiles);\n  }\n\n  getDecisionHistory(): AIDecision[] {\n    return [...this.decisionHistory];\n  }\n\n  isCurrentlyActive(): boolean {\n    return this.isActive;\n  }\n}\n","import { PokerEventType, globalEventBus } from '../core/event-bus.ts';\nimport { AIPersonality, AIPlayer, AIPlayerConfig } from './ai-player.ts';\n\n// 🎮 AI实例管理器配置\nexport interface AIManagerConfig {\n  maxAIPlayers: number;\n  defaultTimeout: number;\n  apiConfig: {\n    apiKey: string;\n    baseUrl: string;\n    model: string;\n  };\n  enablePerformanceMonitoring: boolean;\n}\n\n// 📊 AI性能指标\nexport interface AIPerformanceMetrics {\n  playerId: string;\n  playerName: string;\n  averageDecisionTime: number;\n  successRate: number;\n  timeoutCount: number;\n  totalDecisions: number;\n  lastDecisionTime: number;\n  isHealthy: boolean;\n}\n\n// 🚨 AI健康状态\nexport interface AIHealthStatus {\n  playerId: string;\n  status: 'healthy' | 'warning' | 'critical' | 'offline';\n  lastHeartbeat: number;\n  consecutiveFailures: number;\n  issues: string[];\n}\n\n// 🤖 AI实例管理器\nexport class AIInstanceManager {\n  private aiPlayers: Map<string, AIPlayer> = new Map();\n  private performanceMetrics: Map<string, AIPerformanceMetrics> = new Map();\n  private healthStatus: Map<string, AIHealthStatus> = new Map();\n  private config: AIManagerConfig;\n  private monitoringInterval: NodeJS.Timeout | null = null;\n\n  constructor(config: AIManagerConfig) {\n    this.config = config;\n    this.setupEventListeners();\n    \n    if (config.enablePerformanceMonitoring) {\n      this.startPerformanceMonitoring();\n    }\n    \n    console.log('🤖 AI实例管理器初始化完成');\n    console.log('📊 配置:', config);\n  }\n\n  // 🎧 设置事件监听\n  private setupEventListeners(): void {\n    // 监听AI决策开始\n    globalEventBus.subscribe(PokerEventType.AI_DECISION_START, (event) => {\n      this.onAIDecisionStart(event);\n    });\n\n    // 监听AI决策完成\n    globalEventBus.subscribe(PokerEventType.AI_DECISION_COMPLETE, (event) => {\n      this.onAIDecisionComplete(event);\n    });\n\n    // 监听AI决策超时\n    globalEventBus.subscribe(PokerEventType.AI_DECISION_TIMEOUT, (event) => {\n      this.onAIDecisionTimeout(event);\n    });\n\n    // 监听错误事件\n    globalEventBus.subscribe(PokerEventType.ERROR_OCCURRED, (event) => {\n      if (event.playerId && this.aiPlayers.has(event.playerId)) {\n        this.onAIError(event);\n      }\n    });\n  }\n\n  // 🚀 创建AI玩家\n  createAIPlayer(name: string, personality?: Partial<AIPersonality>): AIPlayer {\n    if (this.aiPlayers.size >= this.config.maxAIPlayers) {\n      throw new Error(`AI玩家数量已达上限: ${this.config.maxAIPlayers}`);\n    }\n\n    const playerId = `ai_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;\n    \n    const defaultPersonality: AIPersonality = {\n      aggression: 0.5,\n      tightness: 0.5,\n      bluffFrequency: 0.2,\n      adaptability: 0.7,\n      riskTolerance: 0.5\n    };\n\n    const aiConfig: AIPlayerConfig = {\n      id: playerId,\n      name,\n      personality: { ...defaultPersonality, ...personality },\n      apiConfig: {\n        ...this.config.apiConfig,\n        temperature: 0.1,\n        maxTokens: 150\n      },\n      decisionTimeoutMs: this.config.defaultTimeout\n    };\n\n    const aiPlayer = new AIPlayer(aiConfig);\n    \n    // 注册AI玩家\n    this.aiPlayers.set(playerId, aiPlayer);\n    \n    // 初始化性能指标\n    this.performanceMetrics.set(playerId, {\n      playerId,\n      playerName: name,\n      averageDecisionTime: 0,\n      successRate: 1.0,\n      timeoutCount: 0,\n      totalDecisions: 0,\n      lastDecisionTime: 0,\n      isHealthy: true\n    });\n\n    // 初始化健康状态\n    this.healthStatus.set(playerId, {\n      playerId,\n      status: 'healthy',\n      lastHeartbeat: Date.now(),\n      consecutiveFailures: 0,\n      issues: []\n    });\n\n    console.log(`🚀 创建AI玩家: ${name} (${playerId})`);\n    console.log(`🎭 性格特征:`, aiConfig.personality);\n\n    return aiPlayer;\n  }\n\n  // 🗑️ 移除AI玩家\n  removeAIPlayer(playerId: string): boolean {\n    const aiPlayer = this.aiPlayers.get(playerId);\n    if (!aiPlayer) {\n      console.warn(`⚠️ AI玩家不存在: ${playerId}`);\n      return false;\n    }\n\n    this.aiPlayers.delete(playerId);\n    this.performanceMetrics.delete(playerId);\n    this.healthStatus.delete(playerId);\n\n    console.log(`🗑️ 移除AI玩家: ${aiPlayer.getName()} (${playerId})`);\n    return true;\n  }\n\n  // 🎯 获取AI玩家\n  getAIPlayer(playerId: string): AIPlayer | undefined {\n    return this.aiPlayers.get(playerId);\n  }\n\n  // 📋 获取所有AI玩家\n  getAllAIPlayers(): AIPlayer[] {\n    return Array.from(this.aiPlayers.values());\n  }\n\n  // 📊 获取性能指标\n  getPerformanceMetrics(playerId?: string): AIPerformanceMetrics[] {\n    if (playerId) {\n      const metrics = this.performanceMetrics.get(playerId);\n      return metrics ? [metrics] : [];\n    }\n    return Array.from(this.performanceMetrics.values());\n  }\n\n  // 🏥 获取健康状态\n  getHealthStatus(playerId?: string): AIHealthStatus[] {\n    if (playerId) {\n      const status = this.healthStatus.get(playerId);\n      return status ? [status] : [];\n    }\n    return Array.from(this.healthStatus.values());\n  }\n\n  // 🔄 开始性能监控\n  private startPerformanceMonitoring(): void {\n    this.monitoringInterval = setInterval(() => {\n      this.performHealthCheck();\n      this.updatePerformanceMetrics();\n    }, 5000); // 每5秒检查一次\n\n    console.log('📊 AI性能监控已启动');\n  }\n\n  // 🛑 停止性能监控\n  stopPerformanceMonitoring(): void {\n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval);\n      this.monitoringInterval = null;\n      console.log('🛑 AI性能监控已停止');\n    }\n  }\n\n  // 🏥 执行健康检查\n  private performHealthCheck(): void {\n    const now = Date.now();\n    \n    this.healthStatus.forEach((status, playerId) => {\n      const timeSinceLastHeartbeat = now - status.lastHeartbeat;\n      const metrics = this.performanceMetrics.get(playerId);\n      \n      // 更新健康状态\n      if (timeSinceLastHeartbeat > 60000) { // 1分钟无响应\n        status.status = 'offline';\n        status.issues.push('长时间无响应');\n      } else if (status.consecutiveFailures >= 3) {\n        status.status = 'critical';\n        status.issues.push('连续决策失败');\n      } else if (metrics && metrics.averageDecisionTime > this.config.defaultTimeout * 0.8) {\n        status.status = 'warning';\n        status.issues.push('决策时间过长');\n      } else {\n        status.status = 'healthy';\n        status.issues = [];\n      }\n\n      // 发送健康状态事件\n      if (status.status !== 'healthy') {\n        globalEventBus.emit(PokerEventType.WARNING_ISSUED, {\n          playerId,\n          healthStatus: status,\n          message: `AI玩家健康状态: ${status.status}`\n        }, playerId);\n      }\n    });\n  }\n\n  // 📈 更新性能指标\n  private updatePerformanceMetrics(): void {\n    this.performanceMetrics.forEach((metrics) => {\n      // 更新健康状态\n      metrics.isHealthy = metrics.successRate > 0.8 && \n                         metrics.averageDecisionTime < this.config.defaultTimeout * 0.8;\n    });\n  }\n\n  // 🎯 处理AI决策开始事件\n  private onAIDecisionStart(event: any): void {\n    const playerId = event.playerId;\n    const status = this.healthStatus.get(playerId);\n    \n    if (status) {\n      status.lastHeartbeat = Date.now();\n    }\n  }\n\n  // ✅ 处理AI决策完成事件\n  private onAIDecisionComplete(event: any): void {\n    const playerId = event.playerId;\n    const decision = event.data.decision;\n    \n    this.updateMetricsOnSuccess(playerId, decision.decisionTime);\n  }\n\n  // ⏰ 处理AI决策超时事件\n  private onAIDecisionTimeout(event: any): void {\n    const playerId = event.playerId;\n    \n    this.updateMetricsOnTimeout(playerId);\n  }\n\n  // ❌ 处理AI错误事件\n  private onAIError(event: any): void {\n    const playerId = event.playerId!;\n    \n    this.updateMetricsOnError(playerId, event.data.error);\n  }\n\n  // 📊 更新成功指标\n  private updateMetricsOnSuccess(playerId: string, decisionTime: number): void {\n    const metrics = this.performanceMetrics.get(playerId);\n    const status = this.healthStatus.get(playerId);\n    \n    if (metrics) {\n      metrics.totalDecisions++;\n      metrics.lastDecisionTime = decisionTime;\n      \n      // 更新平均决策时间\n      metrics.averageDecisionTime = \n        (metrics.averageDecisionTime * (metrics.totalDecisions - 1) + decisionTime) / metrics.totalDecisions;\n      \n      // 更新成功率\n      const successfulDecisions = metrics.totalDecisions - metrics.timeoutCount;\n      metrics.successRate = successfulDecisions / metrics.totalDecisions;\n    }\n\n    if (status) {\n      status.consecutiveFailures = 0;\n      status.lastHeartbeat = Date.now();\n    }\n  }\n\n  // ⏰ 更新超时指标\n  private updateMetricsOnTimeout(playerId: string): void {\n    const metrics = this.performanceMetrics.get(playerId);\n    const status = this.healthStatus.get(playerId);\n    \n    if (metrics) {\n      metrics.totalDecisions++;\n      metrics.timeoutCount++;\n      metrics.lastDecisionTime = this.config.defaultTimeout;\n      \n      // 更新成功率\n      const successfulDecisions = metrics.totalDecisions - metrics.timeoutCount;\n      metrics.successRate = successfulDecisions / metrics.totalDecisions;\n    }\n\n    if (status) {\n      status.consecutiveFailures++;\n      status.lastHeartbeat = Date.now();\n    }\n  }\n\n  // ❌ 更新错误指标\n  private updateMetricsOnError(playerId: string, error: string): void {\n    const status = this.healthStatus.get(playerId);\n    \n    if (status) {\n      status.consecutiveFailures++;\n      status.issues.push(error);\n      status.lastHeartbeat = Date.now();\n      \n      // 限制问题列表长度\n      if (status.issues.length > 5) {\n        status.issues.shift();\n      }\n    }\n  }\n\n  // 📈 生成性能报告\n  generatePerformanceReport(): string {\n    const allMetrics = this.getPerformanceMetrics();\n    const allStatus = this.getHealthStatus();\n    \n    const totalAI = allMetrics.length;\n    const healthyAI = allStatus.filter(s => s.status === 'healthy').length;\n    const averageDecisionTime = allMetrics.reduce((sum, m) => sum + m.averageDecisionTime, 0) / totalAI;\n    const averageSuccessRate = allMetrics.reduce((sum, m) => sum + m.successRate, 0) / totalAI;\n\n    return `\n📈 AI实例管理器性能报告\n========================\n总AI数量: ${totalAI}\n健康AI数量: ${healthyAI}\n平均决策时间: ${averageDecisionTime.toFixed(2)}ms\n平均成功率: ${(averageSuccessRate * 100).toFixed(1)}%\n\n个体性能:\n${allMetrics.map(m => \n  `${m.playerName}: ${m.averageDecisionTime.toFixed(0)}ms, ${(m.successRate * 100).toFixed(1)}% 成功率`\n).join('\\n')}\n\n健康状态:\n${allStatus.map(s => \n  `${s.playerId}: ${s.status}${s.issues.length > 0 ? ` (${s.issues.join(', ')})` : ''}`\n).join('\\n')}\n`;\n  }\n\n  // 🧹 清理资源\n  cleanup(): void {\n    this.stopPerformanceMonitoring();\n    this.aiPlayers.clear();\n    this.performanceMetrics.clear();\n    this.healthStatus.clear();\n    \n    console.log('🧹 AI实例管理器资源已清理');\n  }\n}\n"],"names":["PokerEventType","EventPriority","globalEventBus","constructor","handlers","Map","eventHistory","eventQueue","isProcessing","stats","maxHistorySize","this","totalEvents","eventsByType","eventsByPriority","averageProcessingTime","errorCount","startEventProcessing","subscribe","eventType","handler","has","set","get","push","console","log","index","indexOf","splice","emit","data","playerId","priority","arguments","length","undefined","MEDIUM","event","id","generateEventId","type","timestamp","Date","now","sort","a","b","emitImmediate","CRITICAL","processEvent","setInterval","processNextEvent","shift","startTime","addToHistory","promises","map","async","error","Promise","all","updateStats","processingTime","typeCount","priorityCount","getEventHistory","filter","events","types","e","includes","timeRange","start","end","getStats","clearHistory","Math","random","toString","substr","getPerformanceReport","toFixed","Array","from","entries","_ref","count","join","_ref2","AIPlayer","config","gameState","holeCards","opponentProfiles","decisionHistory","isActive","currentDecisionPromise","setupEventListeners","name","personality","GAME_STARTED","onGameStarted","CARDS_DEALT","onCardsDealt","cards","PLAYER_TURN_START","onMyTurn","PLAYER_ACTION","onOpponentAction","initializeOpponentProfiles","formatCards","analyzeHoleCards","AI_DECISION_START","playerName","decision","makeDecision","AI_DECISION_COMPLETE","executeDecision","AI_DECISION_TIMEOUT","message","action","amount","confidence","reasoning","decisionTime","decisionTimeoutMs","metadata","handStrength","positionFactor","opponentAdjustment","playType","actionData","updateOpponentProfile","calculateHandStrength","playability","calculatePlayability","timeoutPromise","_","reject","setTimeout","Error","decisionPromise","performDecisionAnalysis","race","position","getMyPosition","potOdds","calculatePotOdds","bigBlind","players","forEach","player","vpip","pfr","aggression","tightness","bluffFrequency","positionAwareness","recentActions","lastUpdate","tendency","size","_this$gameState","profile","phase","outcome","card1","card2","rank1","getCardRankValue","rank","rank2","strength","max","suit","gap","abs","min","myIndex","findIndex","p","dealerIndex","totalPlayers","positionIndex","toCall","currentBet","pot","card","getId","getName","getOpponentProfiles","getDecisionHistory","isCurrentlyActive","AIInstanceManager","aiPlayers","performanceMetrics","healthStatus","monitoringInterval","enablePerformanceMonitoring","startPerformanceMonitoring","onAIDecisionStart","onAIDecisionComplete","onAIDecisionTimeout","ERROR_OCCURRED","onAIError","createAIPlayer","maxAIPlayers","aiConfig","adaptability","riskTolerance","apiConfig","temperature","maxTokens","defaultTimeout","aiPlayer","averageDecisionTime","successRate","timeoutCount","totalDecisions","lastDecisionTime","isHealthy","status","lastHeartbeat","consecutiveFailures","issues","removeAIPlayer","delete","warn","getAIPlayer","getAllAIPlayers","values","getPerformanceMetrics","metrics","getHealthStatus","performHealthCheck","updatePerformanceMetrics","stopPerformanceMonitoring","clearInterval","timeSinceLastHeartbeat","WARNING_ISSUED","updateMetricsOnSuccess","updateMetricsOnTimeout","updateMetricsOnError","successfulDecisions","generatePerformanceReport","allMetrics","allStatus","totalAI","healthyAI","s","reduce","sum","m","averageSuccessRate","cleanup","clear"],"sourceRoot":""}